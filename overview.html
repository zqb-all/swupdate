

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>嵌入式系统的软件管理 &mdash; Embedded Software Update Documentation 2018.11 文档</title>
  

  
  
    <link rel="shortcut icon" href="_static/SWUpdate.ico"/>
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" />
    <link rel="next" title="许可证" href="licensing.html" />
    <link rel="prev" title="更新一个嵌入式系统" href="index.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Embedded Software Update Documentation
          

          
          </a>

          
            
            
              <div class="version">
                2018.11
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">嵌入式系统的软件管理</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">通过引导加载程序完成更新</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id3">引导加载程序对外围设备的使用有局限性</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">引导加载程序的驱动程序不会被更新</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">简化版的文件系统</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">网络支持有限</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">与操作人员交互</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id8">引导加载程序更新的优点</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id9">通过包管理器更新</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id10">应用程序进行软件升级的策略</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id11">双备份系统 - 支持回退</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id12">单系统 - 以独立镜像形式运行</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id13">有些事情出错了 ?</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id14">意外掉电</a></li>
<li class="toctree-l3"><a class="reference internal" href="#swupdate">升级SWUpdate本身会如何?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id15">升级引导加载程序会如何?</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="licensing.html">许可证</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="swupdate.html">SWUpdate: 嵌入式系统的软件升级</a></li>
<li class="toctree-l1"><a class="reference internal" href="sw-description.html">SWUpdate:使用默认解析器的语法和标记</a></li>
<li class="toctree-l1"><a class="reference internal" href="signed_images.html">从可信的来源更新镜像</a></li>
<li class="toctree-l1"><a class="reference internal" href="encrypted_images.html">对称加密更新镜像</a></li>
<li class="toctree-l1"><a class="reference internal" href="handlers.html">处理程序</a></li>
<li class="toctree-l1"><a class="reference internal" href="mongoose.html">Mongoose 守护进程模式</a></li>
<li class="toctree-l1"><a class="reference internal" href="suricatta.html">Suricatta 守护进程模式</a></li>
<li class="toctree-l1"><a class="reference internal" href="swupdate-ipc.html">SWUpdate:用于外部程序的API</a></li>
<li class="toctree-l1"><a class="reference internal" href="progress.html">在运行更新时获取信息</a></li>
<li class="toctree-l1"><a class="reference internal" href="building-with-yocto.html">meta-swupdate: 使用Yocto进行编译</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="help_and_support.html">帮助和支持</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">为SWUpdate做贡献</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="roadmap.html">项目规划</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Embedded Software Update Documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>嵌入式系统的软件管理</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/overview.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>嵌入式系统的软件管理<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<p>嵌入式系统变得越来越复杂，
它们的软件也反映了这种复杂性的增加。
为了支持新的特性和修复，很有必要让嵌入式系统上的软件
能够以绝对可靠的方式更新。
在基于linux的系统上，我们可以在大多数情况下找到
以下元素:</p>
<ul class="simple">
<li>引导装载程序</li>
<li>内核和设备树</li>
<li>根文件系统</li>
<li>其他在后续挂载的文件系统</li>
<li>用户资料，以裸数据格式存在或者保存在文件系统中</li>
<li>特定用途的软件. 如，用于下载到相连接的微控制器的固件等</li>
</ul>
<p>一般来说，在大多数情况下是需要更新
内核和根文件系统，保存用户数据-但实际情况各不相同。</p>
<p>仅在少数情况下，还需要更新引导加载程序，
事实上，更新引导加载程序总是很危险的，
因为更新中的失败会破坏设备。
在某些情况下，从损坏状态中恢复是可能的，
但这通常无法由最终用户完成，即设备需要返厂维修。</p>
<p>关于软件更新有很多不同的概念。
我将解释其中的一些概念，
然后解释为什么我实施了这个项目。</p>
<div class="section" id="id2">
<h2>通过引导加载程序完成更新<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>引导加载程序所做的工作远不止启动内核那么简单。
它们有自己的shell，且可以使用处理器的外围设备
进行管理，在大多数情况下是通过串行通讯。
它们通常是可执行脚本的，这使得
实现某种软件更新机制成为了可能。</p>
<p>然而，我发现这种方法有一些缺点，
这让我另行寻找基于运行在Linux上的应用程序的解决方案。</p>
<div class="section" id="id3">
<h3>引导加载程序对外围设备的使用有局限性<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p>并不是所有内核中支持的设备都可以在引导加载程序使用。
向内核添加设备支持是有意义的，因为这可以让外围设备对主应用程序可用，
但将驱动程序移植到引导加载程序中，就并不总是有意义的了。</p>
</div>
<div class="section" id="id4">
<h3>引导加载程序的驱动程序不会被更新<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p>引导加载程序的驱动程序大多是从Linux内核移植过来的，
但是由于经过调整的原因，它们以后不会被修复或与内核同步，
而bug修复则会定期在Linux内核中进行。</p>
<p>一些外围设备可能以不可靠的方式工作，
并且修复问题可能并不容易。引导加载程序中的驱动程序
或多或少是内核中相应驱动程序的复刻(fork)。</p>
<p>例如，用于NAND设备的UBI/UBIFS在内核中包含
了许多修复程序，这些修复程序并没有移植回引导加载程序。</p>
<p>USB协议栈也可以找到相同的情况。支持新外围设备或协议的工作,
在内核中进行得更好，而不是在引导加载程序中。</p>
</div>
<div class="section" id="id5">
<h3>简化版的文件系统<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p>支持的文件系统的数量是有限的。
将文件系统支持移植到引导加载程序需要付出很大的努力。</p>
</div>
<div class="section" id="id6">
<h3>网络支持有限<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<p>网络协议栈是有限的，通常通过一个更新只能通过
UDP但不能通过TCP完成。</p>
</div>
<div class="section" id="id7">
<h3>与操作人员交互<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<p>很难将接口暴露给操作员，
比如浏览器中的GUI或显示器上的GUI。</p>
<p>比起在引导加载程序中，复杂的逻辑可以在应用程序内部更容易实现。
扩展引导加载程序是复杂的，因为所有的服务和库都不可用。</p>
</div>
<div class="section" id="id8">
<h3>引导加载程序更新的优点<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h3>
<p>然而，这种方法也有一些优点：</p>
<p>-更新软件通常更简单。
-占用空间更小：即使是一个仅用于软件管理的独立应用程序
也需要自己的内核和根文件系统。即使它们的大小能够被裁剪，
将更新软件不需要的部分去掉，它们的大小也是不可忽略的。</p>
</div>
</div>
<div class="section" id="id9">
<h2>通过包管理器更新<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h2>
<p>所有的Linux发行版都使用包管理器做更新，
为什么这不适用于嵌入式系统？</p>
<p>我不能说它不能被使用，但是使用这种方法有一个重要的缺点。
嵌入式系统是使用特定的软件进行过良好测试的。
使用包管理器可能会让人觉得奇怪，因为软件本身不再是 <em>原子的</em> ，
而是分裂成一系列包。
我们怎样才能保证一个能基于库版本x.y正常工作的应用程序，
同样也能基于同一个库的不同版本工作呢?如何才能成功地做好测试?</p>
<p>对于制造商来说，通常更好的说法是发布了一个新的软件版本
(经过测试工程师的良好测试)，并且可以更新新的软件(或固件)。
对测试人员来说，在包中进行拆分可能会产生噩梦和巨大的工作量。</p>
<p>简单地替换单个文件可以加快开发速度，
但是对于客户站点来说，这是一个软件版本的噩梦。
如果客户报告了一个bug，那么在之前已经向客户发送过
一些文件的补丁时，软件怎么可能还算是“2.5版本”呢?</p>
<p>原子更新通常是嵌入式系统的必备特性。</p>
</div>
<div class="section" id="id10">
<h2>应用程序进行软件升级的策略<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h2>
<p>应用程序也可以用于升级系统，而不是使用引导加载程序。
应用程序可以使用操作系统提供的所有服务。
建议的解决方案是一个独立的软件，
它遵循客户规则，执行检查以确定软件是否可安装，
然后将软件安装到所需的存储上。</p>
<p>应用程序可以检测所提供的新软件是否适合硬件，
也可以检查软件是否由经过验证的权威机构发布。
支持的特性范围可以从小型系统扩展到复杂系统，
包括安装前和安装后脚本等等。</p>
<p>根据系统的资源，可以使用不同的策略。
下面我将列出其中一些。</p>
<div class="section" id="id11">
<h3>双备份系统 - 支持回退<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h3>
<p>如果存储空间足够保存整个软件的两个副本，
那么即使软件更新被中断或断电，也可以保证始终有一个可用的副本。</p>
<p>每个副本必须包含内核、根文件系统和每个可以更新的组件。
需要一种机制来识别正在运行的版本。</p>
<p>SWUpdate应该集成到应用程序软件中，
当需要更新时，应用程序软件将触发它。
SWUpdate的职责是更新备用副本，
不修改正在运行的软件副本。</p>
<p>与引导加载程序的协作通常是必要的，
因为引导加载程序必须决定应该启动哪个副本。
同样，必须能够在两个副本之间进行切换。</p>
<p>重新启动后，引导加载程序决定应该运行哪个副本。</p>
<img alt="_images/double_copy_layout.png" src="_images/double_copy_layout.png" />
<p>请参阅有关引导加载程序的章节，
了解可以实现哪些机制来确保更新后目标不会被破坏。</p>
<p>最明显的缺点是所需的空间量。
每个副本的可用空间小于存储空间的一半。
然而，即使在断电的情况下，更新也总是安全的。</p>
<p>这个项目支持这个策略。
作为该项目一部分的应用程序应该安装在根文件系统中，
并根据需要启动或触发。不需要额外的内核，
因为这两个副本保证总是可以升级不运行的副本。</p>
<p>SWUpdate将设置bootloader变量以通知新映像已成功安装。</p>
</div>
<div class="section" id="id12">
<h3>单系统 - 以独立镜像形式运行<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h3>
<p>软件升级应用程序由内核（可裁剪掉不必要的驱动等）
和一个小的根文件系统以及应用程序及其库组成。
整个大小远远小于系统软件的一个副本。
根据设置，这个独立根文件系统的大小从 2.5MB 到 8MB 不等。
如果说大小对于小型系统非常重要，
那么对于具有大量存储或大容量NAND的系统，
其大小则可以忽略不计。</p>
<p>系统可以进入 “升级” 模式，只需向引导加载程序发出必须启动升级软件的信号。
具体方法可能有所不同，例如设置引导加载程序环境或使用和外部GPIO。</p>
<p>引导加载程序启动“SWUpdate”，
引导SWUpdate内核并将initrd映像作为根文件系统。
因为它在RAM中运行，所以可以升级整个存储。
与双拷贝策略不同，系统必须重新启动以将其自身置于更新模式。</p>
<p>这个方案比起使用两个副本，占用的存储空间更少，
但是它不能保证在不再次更新软件的情况下进行回退。
不过，至少它可以保证，当主应用不存在或损坏时，
以及当升级过程由于某种原因而中断时，系统自动进入升级模式。</p>
<img alt="_images/single_copy_layout.png" src="_images/single_copy_layout.png" />
<p>事实上，可以将升级过程视为事务，
只有成功升级后，新软件才设置为“可引导”。
考虑到这些因素，使用此策略进行升级是安全的:
如果旧软件损坏或无法运行，
始终确保系统启动并准备好获得新软件。</p>
<p>使用U-Boot作为引导加载程序，
SWUpdate能够管理U-Boot的环境设置变量，
以指示事务的开始和结束，以及包含有效的软件的存储区域。
针对GRUB环境块修改和EFI Boot Guard的类似特性也已被引入。</p>
<p>SWUpdate主要以如下配置的方式使用。
Yocto生成包含SWUpdate应用程序的initrd映像，
该映像在挂载根文件系统之后自动启动。</p>
<img alt="_images/swupdate_single.png" src="_images/swupdate_single.png" />
</div>
</div>
<div class="section" id="id13">
<h2>有些事情出错了 ?<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h2>
<p>许多事情都可能出错，必须保证系统能够再次运行，
并且可能能够重新加载新的软件来修复损坏的映像。
SWUpdate与引导加载程序一起工作，以识别失败的可能原因。
目前支持U-Boot、GRUB和EFI Boot Guard。</p>
<p>我们至少可以列出一些常见的原因:</p>
<dl class="docutils">
<dt>-安装过程中镜像损坏。</dt>
<dd>SWUpdate能够识别它，并且更新过程会被中止。
旧的软件被保存下来，没有任何东西被真正复制到目标的存储中</dd>
</dl>
<ul class="simple">
<li>存储(flash)中损坏的镜像</li>
<li>远程更新由于通信问题而中断</li>
<li>意外掉电</li>
</ul>
<p>SWUpdate的工作流程是事务性的。引导加载程序的环境变量“recovery_status”
被设置为向引导加载程序发出更新状态的信号。
当然，还可以添加更多变量，用于微调和报告错误原因。
recovery_status可以取值为“progress”，“failed”，或者它也可以被取消设置。</p>
<p>当SWUpdate启动时，它将recovery_status设置为“progress”。
更新成功完成后，变量将被删除。如果更新以错误结束，
recovery_status的值为“failed”。</p>
<p>当更新被中断时，不管什么原因，引导加载程序都能识别到，
因为recovery_status变量处于“progress”或“failed”状态。
然后，引导加载程序可以再次启动SWUpdate，以再次
加载软件(单副本情况)或运行应用程序的旧副本(双副本情况)。</p>
<div class="section" id="id14">
<h3>意外掉电<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h3>
<p>如果发生掉电，必须保证系统能够再次工作 —— 重新
启动SWUpdate或恢复软件的旧副本。</p>
<p>一般情况下，行为可以根据所选择的场景进行划分：</p>
<ul class="simple">
<li>单拷贝：SWUpdate被中断，更新事务没有以成功结束。
引导加载程序能够再次启动SWUpdate，从而有可能再次更新软件。</li>
<li>双拷贝：SWUpdate没有在备份系统和当前系统之间做切换。
当前版本的软件，并没有被更新触及到，会再次启动。</li>
</ul>
<p>为了完全安全，SWUpdate和引导加载程序需要交换一些信息。
引导加载程序必须检测更新是否由于断电而中断，
并重新启动SWUpdate，直到更新成功。</p>
<p>SWUpdate支持U-Boot、GRUB和EFI Boot Guard引导加载程序。
U-Boot和EFI Boot Guard有用于保证掉电安全的环境变量，
SWUpdate能够读取和更改这些变量，以此与引导加载程序通信。
对于GRUB，则使用固定的1024字节环境变量块文件。
SWUpdate在开始更新系统时设置一个变量作为标志，
并在完成之后重置同一变量。引导加载程序可以读取此标志，
以检查在上次关机之前是否正在运行更新。</p>
<img alt="_images/SoftwareUpdateU-Boot.png" src="_images/SoftwareUpdateU-Boot.png" />
</div>
<div class="section" id="swupdate">
<h3>升级SWUpdate本身会如何?<a class="headerlink" href="#swupdate" title="永久链接至标题">¶</a></h3>
<p>SWUpdate被认为用于整个开发过程，代替定制过程以在开发过程中更新软件。
在投产前，SWUpdate被针对这个项目进行过很好的测试。</p>
<p>如果SWUpdate本身应该被更新，那么当存储中只有一个SWUpdate副本时，
更新就不是安全的。只有当SWUpdate拥有两个副本时，才能保证安全更新。</p>
<p>如果SWUpdate是升级映像的一部分，则有一些方法可以避免这个问题:</p>
<ul class="simple">
<li>有两份SWUpdate</li>
<li>承担风险，但准备一个在引导加载程序中可使用的救援程序。</li>
</ul>
</div>
<div class="section" id="id15">
<h3>升级引导加载程序会如何?<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h3>
<p>更新引导加载程序在大多数情况下无法做到的。
在大多数SOC上，不存在多个引导加载程序的副本，
当引导加载程序被破坏时，板子就无法引导启动了。</p>
<p>一些soc允许拥有多个引导加载程序副本。
但同样，没有通用的解决方案，因为它是 <em>非常</em> 特定于硬件的。</p>
<p>根据我的经验，大多数产品不允许更新引导加载程序。
当产品准备好量产时，还必须要更新引导加载程序，这种情况是非常少见的。</p>
<p>以上结论不适用于更新U-Boot环境变量，这是一种常见的情况。
U-Boot提供整个环境变量的两个副本，从SWUpdate中更新环境是
掉电安全的。其他引导加载程序则不一定具有此功能。</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="licensing.html" class="btn btn-neutral float-right" title="许可证" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral" title="更新一个嵌入式系统" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2013-2018, Stefano Babic

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/translations.js"></script>
    

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>