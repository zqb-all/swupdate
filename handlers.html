

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>处理程序 &mdash; Embedded Software Update Documentation 2018.11 文档</title>
  

  
  
    <link rel="shortcut icon" href="_static/SWUpdate.ico"/>
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" />
    <link rel="next" title="Mongoose 守护进程模式" href="mongoose.html" />
    <link rel="prev" title="对称加密更新镜像" href="encrypted_images.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Embedded Software Update Documentation
          

          
          </a>

          
            
            
              <div class="version">
                2018.11
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="overview.html">嵌入式系统的软件管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="licensing.html">许可证</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="swupdate.html">SWUpdate: 嵌入式系统的软件升级</a></li>
<li class="toctree-l1"><a class="reference internal" href="sw-description.html">SWUpdate:使用默认解析器的语法和标记</a></li>
<li class="toctree-l1"><a class="reference internal" href="signed_images.html">从可信的来源更新镜像</a></li>
<li class="toctree-l1"><a class="reference internal" href="encrypted_images.html">对称加密更新镜像</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">处理程序</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">概览</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">已提供的处理程序</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id4">创建自己的处理程序</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ubi">UBI卷处理程序</a></li>
<li class="toctree-l2"><a class="reference internal" href="#lua">Lua 处理程序</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id5">远程处理程序</a></li>
<li class="toctree-l2"><a class="reference internal" href="#swu">SWU 转发</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ucfw">ucfw 处理程序</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="mongoose.html">Mongoose 守护进程模式</a></li>
<li class="toctree-l1"><a class="reference internal" href="suricatta.html">Suricatta 守护进程模式</a></li>
<li class="toctree-l1"><a class="reference internal" href="swupdate-ipc.html">SWUpdate:用于外部程序的API</a></li>
<li class="toctree-l1"><a class="reference internal" href="progress.html">在运行更新时获取信息</a></li>
<li class="toctree-l1"><a class="reference internal" href="building-with-yocto.html">meta-swupdate: 使用Yocto进行编译</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="help_and_support.html">帮助和支持</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">为SWUpdate做贡献</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="roadmap.html">项目规划</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Embedded Software Update Documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>处理程序</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/handlers.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>处理程序<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<div class="section" id="id2">
<h2>概览<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>很难预见所有可能的安装情况。
SWUpdate不尝试找出并支持所有用例，
而是让开发人员能自由添加自己的安装程序(即新的 <strong>处理程序</strong> )，
它必须负责安装某种类型的镜像。
镜像被标记为一种已定义的类型，将使用特定的处理程序安装。</p>
<p>解析器在 ‘镜像类型’ 和 ‘处理程序’ 之间建立连接。
它维护一个表用于执行安装，其中包含要安装的镜像列表和处理程序。
每个镜像可以有不同的安装程序。</p>
</div>
<div class="section" id="id3">
<h2>已提供的处理程序<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<dl class="docutils">
<dt>主线代码中有用于最常见情况的处理程序。它们包括:</dt>
<dd><ul class="first last simple">
<li>裸数据模式的flash设备(NOR 和 NAND)</li>
<li>UBI卷</li>
<li>裸设备，例如一个SD卡分区</li>
<li>启动引导程序 (U-Boot, GRUB, EFI Boot Guard) 的环境变量</li>
<li>Lua脚本</li>
</ul>
</dd>
</dl>
<p>例如，如果将图像标记为要更新到UBI卷，解析器必须在维护的表中设置 “ubi”
为需要的处理程序，并填充此处理程序所需的其他字段：卷名、大小等等。</p>
</div>
<div class="section" id="id4">
<h2>创建自己的处理程序<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<p>SWUpdate可以使用新的处理程序进行扩展。
用户需要向核心注册自己的处理程序，并且必须提供SWUpdate在需要使用新处理程序
安装镜像时使用的回调。</p>
<p>回调的原型是:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">my_handler</span><span class="p">(</span><span class="n">struct</span> <span class="n">img_type</span> <span class="o">*</span><span class="n">img</span><span class="p">,</span>
        <span class="n">void</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__unused__</span><span class="p">))</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>最重要的参数是指向struct img_type的指针。
它描述单个镜像并通知处理程序镜像必须安装在何处。
输入流的文件描述符会设置为安装镜像的开始，这也是结构的一部分。</p>
<p>结构 <em>img_type</em> 包含指向要安装的镜像的第一个字节的流的文件描述符。
处理程序必须读取整个镜像，当它返回时，
SWUpdate可以继续处理流中的下一个镜像。</p>
<p>SWUpdate提供了一个通用函数来从流中提取数据并复制到其他地方:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">copyfile</span><span class="p">(</span><span class="nb">int</span> <span class="n">fdin</span><span class="p">,</span> <span class="nb">int</span> <span class="n">fdout</span><span class="p">,</span> <span class="nb">int</span> <span class="n">nbytes</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">long</span> <span class="o">*</span><span class="n">offs</span><span class="p">,</span>
        <span class="nb">int</span> <span class="n">skip_file</span><span class="p">,</span> <span class="nb">int</span> <span class="n">compressed</span><span class="p">,</span> <span class="n">uint32_t</span> <span class="o">*</span><span class="n">checksum</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">char</span> <span class="o">*</span><span class="nb">hash</span><span class="p">);</span>
</pre></div>
</div>
<p>fdin是输入流，即来自回调的img-&gt;fdin。对于签名镜像，只需将 <em>hash</em> 传递
给copyfile()来执行检查，就像 <em>checksum</em> 参数一样。如果校验和或散列不匹配，
copyfile()将返回一个错误。处理程序不需要为它们费心。</p>
<p>处理程序如何管理复制的数据，是特定于处理程序本身的。
请参阅提供的处理程序代码以更好地进行理解。</p>
<p>处理程序的开发人员使用以下调用方式注册自己的处理程序：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">__attribute__</span><span class="p">((</span><span class="n">constructor</span><span class="p">))</span>
<span class="n">void</span> <span class="n">my_handler_init</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">register_handler</span><span class="p">(</span><span class="s2">&quot;mytype&quot;</span><span class="p">,</span> <span class="n">my_handler</span><span class="p">,</span> <span class="n">my_mask</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>SWUpdate使用gcc构造函数，并且在初始化SWUpdate时注册所有提供的处理程序。</p>
<p>register_handler的语法如下:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">register_handler</span><span class="p">(</span><span class="n">my_image_type</span><span class="p">,</span> <span class="n">my_handler</span><span class="p">,</span> <span class="n">my_mask</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
</pre></div>
</div>
<p>其中:</p>
<ul class="simple">
<li>my_image_type : 标识自己的新镜像类型的字符串。</li>
<li>my_handler :指向要注册的安装程序的指针。</li>
<li>my_mask : <code class="docutils literal notranslate"><span class="pre">HANDLER_MASK</span></code> 枚举值，指定 my_handler 可处理什么输入类型。</li>
<li>data : 一个可选的指向自定义结构的指针。SWUpdate会将其保存在处理程序
的列表中，并在执行时传递给处理程序。</li>
</ul>
</div>
<div class="section" id="ubi">
<h2>UBI卷处理程序<a class="headerlink" href="#ubi" title="永久链接至标题">¶</a></h2>
<p>UBI卷的处理程序被认为可以在不改变存储布局的情况下更新UBI卷。
卷必须提前设置:处理程序本身不创建卷。它在所有MTD中搜索一个卷
(如果它们没有被列入黑名单:请参阅 UBIBLACKLIST)，以找到要安装映像的卷。
因此，卷在系统内必须是惟一的。
不支持名称相同的两个卷，这会导致不可预知的结果。
SWUpdate将安装镜像到名称匹配的第一个卷，这可能不是期望的行为。</p>
<p>更新卷时，可以保证擦除计数器在更新后不会丢失。
更新的方式与来自mtd-utils的 “ubiupdatevol” 相同。
事实上上，SWUpdate重用了来自mtd-utils (libubi)的同一个库。</p>
<p>SWUpdate通常创建动态卷。如果需要静态卷，请将处理程序的数据字段
设置为 “static”。</p>
<p>如果存储为空，则需要设置布局并创建卷。这可以通过预安装脚本轻松完成。
使用meta-SWUpdate进行构建时，原始的mtd-utils是可用的，
并且可以由Lua脚本调用。</p>
</div>
<div class="section" id="lua">
<h2>Lua 处理程序<a class="headerlink" href="#lua" title="永久链接至标题">¶</a></h2>
<p>除了用C编写处理程序之外，还可以使用在Lua编写，并在SWUpdate启动时加载。
Lua处理程序源代码文件可以通过 <code class="docutils literal notranslate"><span class="pre">CONFIG_EMBEDDED_LUA_HANDLER</span></code> 配置选
项嵌入到SWUpdate二进制文件中，也可以作为 <code class="docutils literal notranslate"><span class="pre">swupdate_handlers.lua</span></code>
安装到目标系统的Lua搜索路径中，这样它就可以在运行时由嵌入的lua解释器加载。</p>
<p>与C处理程序类似，Lua处理程序的原型是</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">lua_handler</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
    <span class="o">...</span>
<span class="n">end</span>
</pre></div>
</div>
<p>其中 <code class="docutils literal notranslate"><span class="pre">image</span></code> 是一个 Lua 表 (包含了
<a class="reference internal" href="sw-description.html#sw-description-attribute-reference"><span class="std std-ref">sw-description’s attribute reference</span></a>)
相关的属性），描述了处理程序要处理的单个工件。</p>
<p>请注意，属性名称中的破折号会被Lua域的下划线所替换，以使其符合惯例，
例如， <code class="docutils literal notranslate"><span class="pre">installed_direct</span></code> 在Lua域中会变为 <code class="docutils literal notranslate"><span class="pre">installed_directy</span></code> 。</p>
<p>要注册Lua处理程序， <code class="docutils literal notranslate"><span class="pre">swupdate</span></code> 模块提供了 <code class="docutils literal notranslate"><span class="pre">swupdate.register_handler()</span></code>
方法，该方法接受处理程序的名称、要以该名称注册的Lua处理程序函数，
以及(可选地)可以调用处理程序的工件类型。
如果没有提供后者，则Lua处理程序将为所有类型的工件注册。
以下调用将上述函数 <code class="docutils literal notranslate"><span class="pre">lua_handler</span></code> 注册为 <em>my_handler</em> ，
该函数可以用于镜像:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">swupdate</span><span class="o">.</span><span class="n">register_handler</span><span class="p">(</span><span class="s2">&quot;my_handler&quot;</span><span class="p">,</span> <span class="n">lua_handler</span><span class="p">,</span> <span class="n">swupdate</span><span class="o">.</span><span class="n">HANDLER_MASK</span><span class="o">.</span><span class="n">IMAGE_HANDLER</span><span class="p">)</span>
</pre></div>
</div>
<p>Lua处理程序可以通过 <code class="docutils literal notranslate"><span class="pre">swupdate.call_handler()</span></code> 方法调用C处理程序(“链式”)。
在表 <code class="docutils literal notranslate"><span class="pre">swupdate.handler</span></code> 中包含已注册的可被调用的C处理程序(作为键)。
下面的Lua代码是一个简单的处理程序链的例子——调用 <code class="docutils literal notranslate"><span class="pre">rawfile</span></code> C处理程序:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">lua_handler</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">swupdate</span><span class="o">.</span><span class="n">handler</span><span class="p">[</span><span class="s2">&quot;rawfile&quot;</span><span class="p">]</span> <span class="n">then</span>
        <span class="n">swupdate</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;rawfile handler not available&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="n">end</span>
    <span class="n">image</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="s2">&quot;/tmp/destination.path&quot;</span>
    <span class="n">local</span> <span class="n">err</span><span class="p">,</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">swupdate</span><span class="o">.</span><span class="n">call_handler</span><span class="p">(</span><span class="s2">&quot;rawfile&quot;</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">~=</span> <span class="mi">0</span> <span class="n">then</span>
        <span class="n">swupdate</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;Error chaining handlers: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">))</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="n">end</span>
    <span class="k">return</span> <span class="mi">0</span>
<span class="n">end</span>
</pre></div>
</div>
<p>注意，当链式调用C处理程序，用于并非Lua处理程序本身所注册的类型的工件时，
<code class="docutils literal notranslate"><span class="pre">image</span></code> 表的值必须满足被调用的C处理程序的期望：考虑上面的Lua处理程序
，通过上述的 <code class="docutils literal notranslate"><span class="pre">swupdate.register_handler()</span></code> 注册为用于”images”
(<code class="docutils literal notranslate"><span class="pre">swupdate.HANDLER_MASK.IMAGE_HANDLER</span></code>)。根据
<a class="reference internal" href="sw-description.html#sw-description-attribute-reference"><span class="std std-ref">sw-description’s attribute reference</span></a>,
“images”工件类型没有 <code class="docutils literal notranslate"><span class="pre">path</span></code> 属性，但是”file”工件类型有。
所以，为了调用 <code class="docutils literal notranslate"><span class="pre">rawfile</span></code> 处理程序， <code class="docutils literal notranslate"><span class="pre">image.path</span></code> 必须在链式
调用 <code class="docutils literal notranslate"><span class="pre">rawfile</span></code> 处理程序之前被设置好，如上例所示。
然而，通常情况下，如果Lua处理程序注册为支持处理 <code class="docutils literal notranslate"><span class="pre">image</span></code> 的同一工件类型，
则不需要进行此类调整。</p>
<p>除了调用C处理程序之外，作为参数传递给Lua处理程序的 <code class="docutils literal notranslate"><span class="pre">image</span></code> 表还有一个
<code class="docutils literal notranslate"><span class="pre">image:copy2file()</span></code> 方法，该方法实现了将输入流的数据写入文件的常见用例，
该文件作为该方法的参数传递。如果成功， <code class="docutils literal notranslate"><span class="pre">image:copy2file()</span></code>  将返回 <code class="docutils literal notranslate"><span class="pre">0</span></code> ,
在失败时则将返回 <code class="docutils literal notranslate"><span class="pre">-1</span></code> 并附带一条错误消息。
下面的Lua代码是一个简单的处理程序调用 <code class="docutils literal notranslate"><span class="pre">image:copy2file()</span></code> 的例子:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">lua_handler</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
    <span class="n">local</span> <span class="n">err</span><span class="p">,</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">image</span><span class="p">:</span><span class="n">copy2file</span><span class="p">(</span><span class="s2">&quot;/tmp/destination.path&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">~=</span> <span class="mi">0</span> <span class="n">then</span>
        <span class="n">swupdate</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;Error calling copy2file: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">))</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="n">end</span>
    <span class="k">return</span> <span class="mi">0</span>
<span class="n">end</span>
</pre></div>
</div>
<p>除了使用 <code class="docutils literal notranslate"><span class="pre">image:copy2file()</span></code> 或链式调用C处理程序外，
作为参数传递给Lua处理程序的 <code class="docutils literal notranslate"><span class="pre">image</span></code> 表还有一个
<code class="docutils literal notranslate"><span class="pre">image:read(&lt;callback()&gt;)</span></code> 方法，该方法从输入流中读取数据，
并对每个读取的块调用Lua回调方法 <code class="docutils literal notranslate"><span class="pre">&lt;callback()&gt;</span></code> , 读取的块
会被作为参数传递进去。成功时， <code class="docutils literal notranslate"><span class="pre">image:read()</span></code> 返回 <code class="docutils literal notranslate"><span class="pre">0</span></code> 。
失败时，返回 <code class="docutils literal notranslate"><span class="pre">-1</span></code> 并附带一条错误信息。
下面的Lua代码是一个简单的处理程序打印工件内容的例子:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">lua_handler</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
    <span class="n">err</span><span class="p">,</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">image</span><span class="p">:</span><span class="n">read</span><span class="p">(</span><span class="n">function</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="n">end</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">~=</span> <span class="mi">0</span> <span class="n">then</span>
        <span class="n">swupdate</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;Error reading image: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">))</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="n">end</span>
    <span class="k">return</span> <span class="mi">0</span>
<span class="n">end</span>
</pre></div>
</div>
<p>使用 <code class="docutils literal notranslate"><span class="pre">image:read()</span></code> 方法，工件的内容可以在Lua中(后)处理并利用
Lua的功能，而不需要依赖于预先存在的C处理程序来达到预期的目的。</p>
<p>正如C处理程序一样，Lua处理程序必须使用其 <code class="docutils literal notranslate"><span class="pre">image</span></code> 参数中描述的工件，
以便SWUpdate可以在Lua处理程序返回后继续处理流中的下一个工件。
链式处理程序可调用 <code class="docutils literal notranslate"><span class="pre">image:copy2file()</span></code> 或使用 <code class="docutils literal notranslate"><span class="pre">image:read()</span></code>
以满足这个要求。</p>
<p>请注意，尽管Lua处理程序的动态特性在技术上允许将它们嵌入在
将要处理的 <code class="docutils literal notranslate"><span class="pre">swu</span></code> 镜像中，但实际上并未被实现的，因为SWUpdate
的行为是动态更改的，这么做会带来一些安全问题，</p>
</div>
<div class="section" id="id5">
<h2>远程处理程序<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<p>远程处理程序是用于绑定到传统安装程序，而不需要在Lua中重写它们。
远程处理程序将要安装的镜像转发到另一个进程，等待确认镜像是否正确安装。
远程处理程序使用zeromq库——这是为了简化基于Unix域套接字的IPC机制的使用。
远程处理程序非常通用，在sw-description中用 “data” 属性描述
如何与外部进程通信。
远程处理程序始终充当客户机，并尝试使用由 “data” 属性标识的套接字进行连接。
例如，使用远程处理程序的可能设置是:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">images</span><span class="p">:</span> <span class="p">(</span>
        <span class="p">{</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;myimage&quot;&quot;;</span>
            <span class="nb">type</span> <span class="o">=</span> <span class="s2">&quot;remote&quot;</span><span class="p">;</span>
            <span class="n">data</span> <span class="o">=</span> <span class="s2">&quot;test_remote&quot;</span><span class="p">;</span>
         <span class="p">}</span>
<span class="p">)</span>
</pre></div>
</div>
<p>连接使用套接字 “/tmp/test_remote” 进行实例化。
如果connect()失败，远程处理程序将发出更新不成功的信号。
来自SWUpdate的每个Zeromq消息都是一个分为两帧的多部分消息:</p>
<blockquote>
<div><ul class="simple">
<li>第一帧包含一个带命令的字符串。</li>
<li>第二帧包含数据，可以是0字节。</li>
</ul>
</div></blockquote>
<p>目前只有两个可能的命令:INIT和DATA。
成功连接后，SWUpdate以以下格式发送初始化字符串:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">INIT</span><span class="p">:</span><span class="o">&lt;</span><span class="n">size</span> <span class="n">of</span> <span class="n">image</span> <span class="n">to</span> <span class="n">be</span> <span class="n">installed</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>外部安装程序被告知要安装的映像的大小，如果需要，它可以分配资源。
它将用字符串 <em>ACK</em> 或 <em>NACK</em> 来回答。SWUpdate接收到的第一个NACK将中断更新。
发送INIT命令后，远程处理程序将发送一系列 <em>DATA</em> 命令，
其中消息中的第二帧将包含要安装的镜像数据块。
外部进程要责任处理这一系列传输的数据，并在接收完最后一个块时释放资源。
对于每个数据消息，外部进程使用 <em>ACK</em> 或 <em>NACK</em> 消息进行响应。</p>
</div>
<div class="section" id="swu">
<h2>SWU 转发<a class="headerlink" href="#swu" title="永久链接至标题">¶</a></h2>
<p>SWU转发器处理程序可用于更新正在运行SWUpdate的其他系统。
它可以用于主/从系统，其中主机连接到网络，而从机则对外界隐藏。
因此，主机是与外部世界的唯一接口。
通常一个SWU镜像可以将另一个SWU镜像作为单个工件进行包含，
SWU处理程序将它转发到工件描述中列出的设备。
处理程序可以有一个带有url数组的 “url” 属性条目。
每个url是一个辅助板的地址，其中运行着激活了webserver的SWUpdate。
SWU处理程序期望与SWUpdate的嵌入式web服务器通信。
这有助于更新正在运行旧版本SWUpdate的系统，
因为嵌入式web服务器是所有版本中都存在的公共特性。
处理程序将同时将嵌入的SWU发送到所有url，该处理程序支持设置
<code class="docutils literal notranslate"><span class="pre">installed_direct</span></code> 。</p>
<img alt="_images/SWUGateway.png" src="_images/SWUGateway.png" />
<p>下面的例子展示了如何将SWU设置为工件并启用SWU转发器:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">images</span><span class="p">:</span> <span class="p">(</span>
        <span class="p">{</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;image.swu&quot;</span><span class="p">;</span>
                <span class="nb">type</span> <span class="o">=</span> <span class="s2">&quot;swuforward&quot;</span><span class="p">;</span>

                <span class="n">properties</span><span class="p">:</span> <span class="p">{</span>
                        <span class="n">url</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;http://192.168.178.41:8080&quot;</span><span class="p">,</span> <span class="s2">&quot;http://192.168.178.42:8080&quot;</span><span class="p">];</span>
                <span class="p">};</span>
        <span class="p">});</span>
</pre></div>
</div>
</div>
<div class="section" id="ucfw">
<h2>ucfw 处理程序<a class="headerlink" href="#ucfw" title="永久链接至标题">¶</a></h2>
<p>此处理程序允许通过UART更新连接到主控制器的单片机上的固件。
用于设置的参数将通过sw-description文件传递。
它的行为可以扩展到更一般的情况。
协议是基于ASCII的。在处理程序发送数据并等待来自单片机的ACK之后，
需要完成一个将单片机置于编程模式的序列。</p>
<p>对固件的编程动作应该如下:</p>
<ol class="arabic simple">
<li><dl class="first docutils">
<dt>进入固件更新模式(引导加载程序)</dt>
<dd><ol class="first last arabic">
<li>将 “复位线” 设置为逻辑 “低”</li>
<li>将 “更新线” 设置为逻辑 “低”</li>
<li>将 “复位线” 设置为逻辑 “高”</li>
</ol>
</dd>
</dl>
</li>
<li>发送编程信息</li>
</ol>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$PROG;&lt;&lt;CS&gt;&gt;&lt;CR&gt;&lt;LF&gt;
</pre></div>
</div>
<p>到单片机。(单片机会保持在编程状态)</p>
<ol class="arabic simple" start="3">
<li>单片机使用以下方式发出确认</li>
</ol>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$READY;&lt;&lt;CS&gt;&gt;&lt;CR&gt;&lt;LF&gt;
</pre></div>
</div>
<p>4.从主板发送数据传输包到单片机</p>
<p>包定义:</p>
<blockquote>
<div><ul class="simple">
<li>在一个包中，记录是一个接一个地发送，没有结束行标记 &lt;CR&gt;&lt;LF&gt;</li>
<li>包以 &lt;CR&gt;&lt;CF&gt; 作为结束</li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="5">
<li>单片机以$READY;&lt;&lt;CS&gt;&gt;&lt;CR&gt;&lt;LF&gt;请求下一个包</li>
<li>重复步骤4和步骤5，直到传输完整个固件。</li>
<li>键盘使用 $COMPLETED;&lt;&lt;CS&gt;&gt;&lt;CR&gt;&lt;LF&gt; 确认更新完成</li>
<li><dl class="first docutils">
<dt>退出升级模式</dt>
<dd><ol class="first last arabic">
<li>设置 “更新线” 为逻辑 “高”</li>
<li>在 “复位线” 上执行复位</li>
</ol>
</dd>
</dl>
</li>
</ol>
<p>&lt;&lt;CS&gt;&gt;:校验和。校验和的计算，是对除开始标记 “$” 之外的消息字符串的所有字节
做和运算，再对256取模，再做补码得到。
处理程序期望从属性中获得用于初始化的复位线和编程线的gpio口。
它们应该是这样的格式:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">properties</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">reset</span> <span class="o">=</span> <span class="s2">&quot;&lt;gpiodevice&gt;:&lt;gpionumber&gt;:&lt;activelow&gt;&quot;</span><span class="p">;</span>
        <span class="n">prog</span> <span class="o">=</span> <span class="s2">&quot;&lt;gpiodevice&gt;:&lt;gpionumber&gt;:&lt;activelow&gt;&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>例子:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">properties</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">reset</span> <span class="o">=</span>  <span class="s2">&quot;/dev/gpiochip0:38:false&quot;</span><span class="p">;</span>
        <span class="n">prog</span> <span class="o">=</span>  <span class="s2">&quot;/dev/gpiochip0:39:false&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="mongoose.html" class="btn btn-neutral float-right" title="Mongoose 守护进程模式" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="encrypted_images.html" class="btn btn-neutral" title="对称加密更新镜像" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2013-2018, Stefano Babic

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/translations.js"></script>
    

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>