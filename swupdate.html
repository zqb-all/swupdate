

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>SWUpdate: 嵌入式系统的软件升级 &mdash; Embedded Software Update Documentation 2018.11 文档</title>
  

  
  
    <link rel="shortcut icon" href="_static/SWUpdate.ico"/>
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" />
    <link rel="next" title="SWUpdate:使用默认解析器的语法和标记" href="sw-description.html" />
    <link rel="prev" title="许可证" href="licensing.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Embedded Software Update Documentation
          

          
          </a>

          
            
            
              <div class="version">
                2018.11
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="overview.html">嵌入式系统的软件管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="licensing.html">许可证</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">SWUpdate: 嵌入式系统的软件升级</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">概述</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id2">功能</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id3">总体概览</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">交付单一镜像</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">流式更新功能</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">完全流式更新镜像</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id7">配置和构建</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id8">需求</a></li>
<li class="toctree-l3"><a class="reference internal" href="#yocto">在Yocto中进行构建</a></li>
<li class="toctree-l3"><a class="reference internal" href="#libubootenv">libubootenv呢 ?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id9">配置SWUpdate</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id10">构建</a></li>
<li class="toctree-l3"><a class="reference internal" href="#debian">编译一个debian包</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id11">编译一个debian包的步骤</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id12">对源包签名的替代方法</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id13">运行SWUpdate</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id14">运行一次swupdate可以期望得到什么</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id15">命令行参数</a></li>
<li class="toctree-l3"><a class="reference internal" href="#systemd">systemd集成</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id17">引导启动程序的修改</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id18">构建一个单个的镜像</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id19">对复合镜像的支持</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="sw-description.html">SWUpdate:使用默认解析器的语法和标记</a></li>
<li class="toctree-l1"><a class="reference internal" href="signed_images.html">从可信的来源更新镜像</a></li>
<li class="toctree-l1"><a class="reference internal" href="encrypted_images.html">对称加密更新镜像</a></li>
<li class="toctree-l1"><a class="reference internal" href="handlers.html">处理程序</a></li>
<li class="toctree-l1"><a class="reference internal" href="mongoose.html">Mongoose 守护进程模式</a></li>
<li class="toctree-l1"><a class="reference internal" href="suricatta.html">Suricatta 守护进程模式</a></li>
<li class="toctree-l1"><a class="reference internal" href="swupdate-ipc.html">SWUpdate:用于外部程序的API</a></li>
<li class="toctree-l1"><a class="reference internal" href="progress.html">在运行更新时获取信息</a></li>
<li class="toctree-l1"><a class="reference internal" href="building-with-yocto.html">meta-swupdate: 使用Yocto进行编译</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="help_and_support.html">帮助和支持</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">为SWUpdate做贡献</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="roadmap.html">项目规划</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Embedded Software Update Documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>SWUpdate: 嵌入式系统的软件升级</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/swupdate.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="swupdate">
<h1>SWUpdate: 嵌入式系统的软件升级<a class="headerlink" href="#swupdate" title="永久链接至标题">¶</a></h1>
<div class="section" id="id1">
<h2>概述<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>本项目被认为有助于从存储媒体或网络更新嵌入式系统。
但是，它应该主要作为一个框架来考虑，在这个框架中可以方便地
向应用程序添加更多的协议或安装程序(在SWUpdate中称为处理程序)。</p>
<p>一个用例是从外部本地媒体(如USB-Pen或sd卡)进行更新。
在这种情况下，更新是在没有操作员干预的情况下完成的:
它被认为是“一键更新”，软件在复位时启动，只需按下一个键
(或者以任何目标可以识别的方式)，自动进行所有检查。
最后，更新过程只向操作员报告状态(成功或失败)。</p>
<p>输出可以使用帧缓冲设备显示在LCD上，
也可以定向到串行通讯端口上(Linux控制台)。</p>
<p>它通常用于单拷贝方案中，在initrd中运行(用Yocto提供的配方生成)。
但是，通过使用软件集合( <a class="reference internal" href="sw-description.html#collections"><span class="std std-ref">软件集合</span></a> )，可以在双拷贝方案中使用它。</p>
<p>如果启动了远程更新，SWUpdate将启动嵌入式web服务器并等待请求。
操作者必须上传一个合适的映像，然后SWUpdate会进行检查并安装。
所有输出都通过AJAX通知的方式通知操作人员的浏览器。</p>
</div>
<div class="section" id="id2">
<h2>功能<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<div class="section" id="id3">
<h3>总体概览<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li>安装在嵌入式介质上(eMMC、SD、Raw NAND、NOR、SPI-NOR flash)</li>
<li>检查镜像是否可用。镜像以指定的格式(cpio)构建，它必须包含一个描述文件，
以描述必须更新的软件。</li>
<li>SWUpdate被认为可以更新设备上的UBI卷(主要用于NAND，
但不限于NAND)和镜像。传递整个镜像仍然用于对SD卡上
的分区或MTD分区进行更新。</li>
<li>新分区模式。这与UBI容量有关。SWUpdate可以重新创建UBI卷，
调整它们的大小并复制新软件。一个名为“data”的特殊UBI卷
在重新分区时，用于保存和恢复数据，以保持好用户数据。</li>
<li>使用zlib库支持压缩镜像。支持tarball (tgz文件)。</li>
<li>支持带分区的USB-pen或未分区盘(主要用于Windows)。</li>
<li>支持更新文件系统中的单个文件。
必须明确描述该文件所在的文件系统位置。</li>
<li>支持图像中单个组件的校验和</li>
<li>使用结构化语言来描述镜像。
这是使用 <a class="reference external" href="http://www.hyperrealm.com/libconfig/">libconfig</a> 库作为缺省解析器完成的，它使用一种类似json的描述。</li>
<li>使用自定义的方式来描述镜像。可以使用Lua语言编写自己的解析器。
examples目录中提供了一个使用Lua中的XML描述的示例。</li>
<li>支持设置/删除U-Boot变量</li>
<li>支持设置/擦除 <a class="reference external" href="https://www.gnu.org/software/grub/manual/html_node/Environment-block.html">GRUB</a> 环境块变量</li>
<li>支持设置/删除 <a class="reference external" href="https://github.com/siemens/efibootguard">EFI Boot Guard</a> 变量</li>
<li>使用嵌入式web服务器的网络安装程序
(在Lua许可下的版本中选择了Mongoose服务器)。
可以使用不同的web服务器。</li>
<li><dl class="first docutils">
<dt>多种获取软件的接口</dt>
<dd><ul class="first last">
<li>本地存储: USB, SD, UART,..</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>OTA / 远程</dt>
<dd><ul class="first last">
<li>集成的网络服务器</li>
<li>从远程服务器拉取(HTTP, HTTPS， ..)</li>
<li>使用后端。SWUpdate是开放的，可以与后端服务器进行通信，
以推出软件更新。当前版本支持Hawkbit服务器，
但可以添加其他后端。</li>
</ul>
</dd>
</dl>
</li>
<li>可以配置为检查软件和硬件之间的兼容性。
软件映像必须包含条目，声明这个软件可在什么版本硬件上运行。
如果没有通过兼容性验证，SWUpdate将拒绝安装。</li>
<li>支持镜像提取。制造商用一个映像包含用于多个设备的软件。
这简化了制造商的管理，并降低了单一软件产品的管理成本。
SWUpdate以流的形式接收软件，不进行临时存储，并只提取需要安装的设备组件。</li>
<li>允许自定义处理器，通过自定义协议安装FPGA固件，微控制器固件。</li>
<li>使用“make menuconfig”启用/禁用特性。(Kbuild继承自busybox项目)</li>
<li>镜像在安装之前经过身份认证和校验</li>
<li>掉电安全</li>
</ul>
</div>
<div class="section" id="id4">
<h3>交付单一镜像<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p>主要概念是制造商提供单个大图像。
所有单个的镜像都被打包在一起(选择cpio是因为它
的简单性和可流式处理)，同时打包的还有另一个文
件(sw-description)，该文件包含每个独立镜像的元信息。</p>
<p>sw-description的格式是可定制的:可以将SWUpdate配置为
使用其内部解析器(基于libconfig)，或者在调用外部的lua解析器。</p>
<img alt="_images/image_format.png" src="_images/image_format.png" />
<p>可以使用外部解析器，改变对镜像的接受规则，以扩展支持新的镜像类型，
指明它们需要如何安装。实际上，解析器就是检索必须安装哪些单个的镜像
以及如何安装。</p>
<p>SWUpdate使用“处理程序”来安装单个镜像:
有用于将镜像安装到UBI卷或SD卡、CFI闪存等的处理程序。
如果需要特殊的安装程序，那么也可以很容易地添加自己的处理程序。</p>
<p>例如，我们可以考虑一个带有主处理器和一个或几个微控制器的项目。
为了简单起见，我们假设主处理器使用专用协议通过UARTS与微控制器通信。
微控制器上的软件可以使用专用协议进行更新。</p>
<p>可以扩展swuodate，编写一个处理程序，实现专用协议的一部分
来对微控制器进行升级。解析器必须识别哪个镜像必须用新的处理
程序来安装，随后SWUpdate将在安装过程中调用该处理程序。</p>
</div>
<div class="section" id="id5">
<h3>流式更新功能<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p>SWUpdate被认为能够将接收到的镜像直接流式更新到目标中，
而不需要任何临时副本。实际上，单个安装程序(处理程序)会接收
一个文件描述符作为输入，该文件描述符设置在必须安装的图像的开始处。</p>
<p>该特性可以基于镜像进行设置，这意味着用户可以决定镜像的哪些部分
应该流式处理。如果没有流式处理(请参见installed-direct标志)，
文件将临时提取到环境变量 <code class="docutils literal notranslate"><span class="pre">TMPDIR</span></code> 指向的目录中，如果没有
设置 <code class="docutils literal notranslate"><span class="pre">TMPDIR</span></code> ，则默认使用 <code class="docutils literal notranslate"><span class="pre">/tmp</span></code> 。
当然，使用流式处理，则不可能在安装之前检查整个交付的软件。
临时副本仅在从网络更新时使用。
当映像存储在外部存储上时，不需要该副本。</p>
</div>
<div class="section" id="id6">
<h3>完全流式更新镜像<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<p>在远程更新的情况下，SWUpdate从流中提取相关图像，并将它们复制
到环境变量 <code class="docutils literal notranslate"><span class="pre">TMPDIR</span></code> (如果未设置，则复制到 <code class="docutils literal notranslate"><span class="pre">/tmp</span></code> )指向的目录中，
然后调用处理程序。这确保只有在所有部件都存在且正确时才会启动更新。
但是，在一些资源较少的系统上，用于复制镜像的RAM空间可能不足，
例如，如果必须更新附加SD卡上的文件系统的话。在这种情况下，如果
图像能由相应的处理程序直接作为流安装，而不需要临时副本的话，
则会很有帮助。并非所有处理程序都支持直接流式更新目标。
零拷贝流是通过在单个镜像像的描述中设置“installed-directly”标志来启用的。</p>
</div>
</div>
<div class="section" id="id7">
<h2>配置和构建<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<div class="section" id="id8">
<h3>需求<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h3>
<p>编译SWUpdate只需要依赖几个库。</p>
<ul class="simple">
<li>mtd-utils: mtd-utils在内部生成libmtd和libubi。它们通常不导出也不安装，
但是SWUpdate将链接它们，以便重用相同的功能来升级MTD和UBI卷。</li>
<li>openssl: web服务器需要。</li>
<li>Lua: liblua和开发头文件。</li>
<li>libz和libcrypto总是需要被链接。</li>
<li>libconfig: 被默认解析器使用。</li>
<li>libarchive (可选的)用于存档处理程序。</li>
<li>libjson (可选的)用于JSON解析器和Hawkbit。</li>
<li>libubootenv (可选的) 如果启用了对U-Boot的支持则需要。</li>
<li>libebgenv (可选的) 如果启用了对EFI Boot Guard的支持则需要。</li>
<li>libcurl 用于网络通讯。</li>
</ul>
<p>新的处理程序可以向需求列表中添加一些其他的库 -
当出现构建错误时，检查是否需要所有的处理程序，然后删除其中不需要的部分。</p>
</div>
<div class="section" id="yocto">
<h3>在Yocto中进行构建<a class="headerlink" href="#yocto" title="永久链接至标题">¶</a></h3>
<p>提供了一个 <a class="reference external" href="https://github.com/sbabic/meta-swupdate.git">meta-swupdate</a> 层.它包含了mtd-utils和生成Lua所需的更改。
使用meta-SWUpdate只需一些简单的步骤。</p>
<p>首先，克隆 meta-swupdate.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">clone</span> <span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">sbabic</span><span class="o">/</span><span class="n">meta</span><span class="o">-</span><span class="n">swupdate</span><span class="o">.</span><span class="n">git</span>
</pre></div>
</div>
<p>像往常一样向 bblayer.conf 添加 meta-swupdate。
你还需要将 meta-oe 添加到list中。</p>
<p>在meta-swupdate中，有一个配方，用于生成带有swupdate的initrd救援系统。
使用：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MACHINE</span><span class="o">=&lt;</span><span class="n">your</span> <span class="n">machine</span><span class="o">&gt;</span> <span class="n">bitbake</span> <span class="n">swupdate</span><span class="o">-</span><span class="n">image</span>
</pre></div>
</div>
<p>你将在 tmp/deploy/&lt;your machine&gt; 目录中找到生成的结果。
如何安装和启动initrd是跟具体目标强相关的 - 请查阅你的
引导加载程序的文档。</p>
</div>
<div class="section" id="libubootenv">
<h3>libubootenv呢 ?<a class="headerlink" href="#libubootenv" title="永久链接至标题">¶</a></h3>
<p>这是构建SWUpdate时常见的问题。SWUpdate依赖于这个库，
它是从U-Boot源码生成的。这个库允许安全地修改U-Boot环境变量。
如果不使用U-Boot作为引导加载程序，则不需要它。
如果无法SWUpdate正常链接，则你使用的是旧版本的U-Boot
(你至少需要2016.05以上的版本)。如果是这样，你可以为
包u-boot-fw-utils添加自己的配方，以添加这个库的代码。</p>
<p>重要的是，包u-boot-fw-utils是用相同的引导加载程序源码和相同的机器构建的。
事实上，设备可以使用一份直接链接到uboot中的默认环境变量，而不需要保存在
存储器上。SWUpdate应该知道这一点，因为它不能读取这份环境变量:默认的这份
环境变量也必须被链接到SWUpdate中。这是在libubootenv内部完成的。</p>
<p>如果构建的时候选择了不同的机器，SWUpdate将在第一次尝试更改环境变量时
破坏环境变量。实际上，使用了错误的默认环境后，你的板子将不能再次被
引导启动。</p>
</div>
<div class="section" id="id9">
<h3>配置SWUpdate<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h3>
<p>SWUpdate可以通过“make menuconfig”配置。
使用内部解析器和禁用web服务器可以达到较小的内存占用。
每个选项都有描述其用法的小帮助说明。
在默认配置中，许多选项已经被激活。</p>
<p>要配置选项请执行:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">menuconfig</span>
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h3>构建<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li>要进行交叉编译，请在运行make之前设置CC和CXX变量。
也可以使用make menuconfig将交叉编译器前缀设置为选项。</li>
<li>生成代码</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span>
</pre></div>
</div>
<p>结果时一个二进制文件“swupdate”。第二个构建的二进制文件
是”process”，但这并非严格要求的。这是一个示例，演示如何
构建自己的SWUpdate接口来在HMI上显示进度条或任何你想要的东西。
具体到这个示例，则是简单地在控制台打印更新的当前状态。</p>
<p>在Yocto构建系统中，:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bitbake</span> <span class="n">swupdate</span>
</pre></div>
</div>
<p>这将进行包的构建</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bitbake</span> <span class="n">swupdate</span><span class="o">-</span><span class="n">image</span>
</pre></div>
</div>
<p>这将构建一个救援镜像。
结果是一个可以由引导加载程序直接加载的Ramdisk。
要在双拷贝模式下使用SWUpdate的话，则将包swupdate放到你的rootfs中。
检查你的镜像配方文件，并简单地将其添加到安装包的列表中。</p>
<p>例如，如果我们想将它添加到标准的“core-image-full-cmdline”镜像中，
我们可以添加一个 <em>recipes-extended/images/core-image-full-cmdline.bbappend</em></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">IMAGE_INSTALL</span> <span class="o">+=</span> <span class="s2">&quot; </span><span class="se">\</span>
<span class="s2">                        swupdate </span><span class="se">\</span>
<span class="s2">                        swupdate-www </span><span class="se">\</span>
<span class="s2">                 &quot;</span>
</pre></div>
</div>
<p>swupdate-www是一个带有网站的软件包，你可以用自己的logo、模板
和风格进行定制。</p>
</div>
<div class="section" id="debian">
<h3>编译一个debian包<a class="headerlink" href="#debian" title="永久链接至标题">¶</a></h3>
<p>SWUpdate被认为是用于嵌入式系统的，在嵌入式发行版中构建
是首要的情况。但是除了最常用的嵌入式构建系统Yocto或
Buildroot之外，在某些情况下还会使用标准的Linux发行版。
不仅如此，发行版包还允许为了测试目的在Linux PC上
运行SWUpdate，而不必与依赖项做斗争。
使用debhelper工具，可以生成debian包。</p>
<div class="section" id="id11">
<h4>编译一个debian包的步骤<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">./</span><span class="n">debian</span><span class="o">/</span><span class="n">rules</span> <span class="n">clean</span>
<span class="o">./</span><span class="n">debian</span><span class="o">/</span><span class="n">rules</span> <span class="n">build</span>
<span class="n">fakeroot</span> <span class="n">debian</span><span class="o">/</span><span class="n">rules</span> <span class="n">binary</span>
</pre></div>
</div>
<p>结果是一个存储在父目录中的“deb”包。</p>
</div>
<div class="section" id="id12">
<h4>对源包签名的替代方法<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h4>
<p>你可以使用dpkg-buildpackage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dpkg</span><span class="o">-</span><span class="n">buildpackage</span> <span class="o">-</span><span class="n">us</span> <span class="o">-</span><span class="n">uc</span>
<span class="n">debsign</span> <span class="o">-</span><span class="n">k</span> <span class="o">&lt;</span><span class="n">keyId</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id13">
<h2>运行SWUpdate<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h2>
<div class="section" id="id14">
<h3>运行一次swupdate可以期望得到什么<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h3>
<p>SWUpdate的运行主要包括以下步骤:</p>
<ul class="simple">
<li>检查介质(usb pen)</li>
<li>检查镜像文件。扩展名必须是.swu</li>
<li>从镜像中提取sw-description并验证它，
它解析sw-description，在RAM中创建关于必须执行的活动的原始描述。</li>
<li>读取cpio归档文件并验证每个文件的校验和，如果归档文件未完全
通过验证，SWUpdate将停止执行。</li>
<li>检查硬件-软件兼容性，如果有的话，从硬件中读取硬件修改，
并与sw-description中的表做匹配。</li>
<li>检查在sw-description中描述的所有组件是否真的在cpio归档中。</li>
<li>如果需要，修改分区。这包含UBI卷的大小调整，而不是MTD分区的大小调整。
一个名为“data”的卷被用于在调整大小时保存和恢复数据。</li>
<li>执行预运行脚本</li>
<li>遍历所有镜像并调用相应的处理程序以便在目标上安装。</li>
<li>执行安装后脚本</li>
<li>如果在sw-description中指定了更改，则更新引导加载程序环境变量。</li>
<li>向操作人员报告状态(stdout)</li>
</ul>
<p>有一个步骤失败，则会停止整个过程并报告错误。</p>
<p>运行SWUpdate从文件中获取镜像:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">swupdate</span> <span class="o">-</span><span class="n">i</span> <span class="o">&lt;</span><span class="n">filename</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>带着嵌入式服务器启动:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">swupdate</span> <span class="o">-</span><span class="n">w</span> <span class="s2">&quot;&lt;web server options&gt;&quot;</span>
</pre></div>
</div>
<p>web服务器主要的重要参数是”document-root”和”port”。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">swupdate</span> <span class="o">-</span><span class="n">w</span> <span class="s2">&quot;--document-root ./www --port 8080&quot;</span>
</pre></div>
</div>
<p>嵌入式web服务器取自Mongoose项目。</p>
<p>检索所有选项列表:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">swupdate</span> <span class="o">-</span><span class="n">h</span>
</pre></div>
</div>
<p>这个完整使用随着代码交付的也没。当然，它们可以定制和替换。
网站使用AJAX与SWUpdate进行通信，并向操作人员显示更新的进度。</p>
<p>web服务器的默认端口是8080。你可以从如下网址连接到目标设备:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">http</span><span class="p">:</span><span class="o">//&lt;</span><span class="n">target_ip</span><span class="o">&gt;</span><span class="p">:</span><span class="mi">8080</span>
</pre></div>
</div>
<p>如果它正常工作，则开始页面应该显示如下图所示。</p>
<img alt="_images/website.png" src="_images/website.png" />
<p>如果下载了正确的镜像，SWUpdate将开始处理接收到的镜像。
所有通知都被发送回浏览器。SWUpdate提供了一种机制，
可以将安装进度发送给接收方。实际上，SWUpdate接受
一个对象列表，这些对象在应用程序中注册了自身，
在调用notify()函数时就会通知它们。
这也允许自行编写处理程序通知上层错误条件或简单地返回状态。
这使得可以简单地添加一个自己的接收器，以实现以自定义的方式
显示结果：在LCD上显示(如果设备上有的话)，或者通过网络发送
回另一个设备。</p>
<p>发送回浏览器的通知示例如下图所示:</p>
<img alt="_images/webprogress.png" src="_images/webprogress.png" />
<p>软件集合可以通过传递 <cite>–select</cite> 命令行选项来指定。
假设 <cite>sw-description</cite> 文件包含一个名为 <cite>stable</cite> 的集合，
加上 <cite>alt</cite> 的安装位置，则可以这样调用 <cite>SWUpdate</cite></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">swupdate</span> <span class="o">--</span><span class="n">select</span> <span class="n">stable</span><span class="p">,</span><span class="n">alt</span>
</pre></div>
</div>
</div>
<div class="section" id="id15">
<h3>命令行参数<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="15%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Type</th>
<th class="head">描述</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>-f &lt;file&gt;</td>
<td>string</td>
<td>要使用的SWUpdate配置文件</td>
</tr>
<tr class="row-odd"><td>-b &lt;string&gt;</td>
<td>string</td>
<td>只有当选上CONFIG_UBIATTACH时才有效，
它在SWUpdate搜索UBI卷时将MTDs列入黑名单。
示例:MTD0-1中的U-BOOT和环境变量
<strong>swupdate -b “0 1”</strong></td>
</tr>
<tr class="row-even"><td>-e &lt;sel&gt;</td>
<td>string</td>
<td>sel 的格式为 &lt;software&gt;,&lt;mode&gt;
它允许在sw-description文件中找到一个规则
的子集。有了这个选项就可以使用多重规则了
一种常见用法是在双拷贝模式下。例如:
-e “stable, copy1”  ==&gt; install on copy1
-e “stable, copy2”  ==&gt; install on copy2</td>
</tr>
<tr class="row-odd"><td>-h</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>使用帮助</td>
</tr>
<tr class="row-even"><td>-k</td>
<td>string</td>
<td>选中 CONFIG_SIGNED 时可用
指定公钥文件</td>
</tr>
<tr class="row-odd"><td>-l &lt;level&gt;</td>
<td>int</td>
<td>设置log级别</td>
</tr>
<tr class="row-even"><td>-L</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>将log输出到 syslog(local)</td>
</tr>
<tr class="row-odd"><td>-i &lt;file&gt;</td>
<td>string</td>
<td>使用本地.swu文件运行SWUpdate</td>
</tr>
<tr class="row-even"><td>-n</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>在模拟(dry-run)模式下运行SWUpdate</td>
</tr>
<tr class="row-odd"><td>-N</td>
<td>string</td>
<td>传入当前安装的软件版本。这将用于检查
新软件版本一起检查，禁止升级到旧版本。
版本号由4个数字组成:
major.minor.rev.build
每个字段都要在0..65535的范围内</td>
</tr>
<tr class="row-even"><td>-o &lt;file&gt;</td>
<td>string</td>
<td>将流(SWU)保存到一个文件中</td>
</tr>
<tr class="row-odd"><td>-v</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>激活详细的输出信息</td>
</tr>
<tr class="row-even"><td>-w &lt;parms&gt;</td>
<td>string</td>
<td>启动内部webserver并将命令行字符串传递给它</td>
</tr>
<tr class="row-odd"><td>-u &lt;parms&gt;</td>
<td>string</td>
<td>启动内部suricatta客户端守护进程，
并将命令行字符串传递给它
详见suricatta的文档</td>
</tr>
<tr class="row-even"><td>-H
&lt;board:rev&gt;</td>
<td>string</td>
<td>设置板名和硬件版本</td>
</tr>
<tr class="row-odd"><td>-c</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>这个选项将检查 <code class="docutils literal notranslate"><span class="pre">*.swu</span></code> 文件的内部。
它确保sw-description中引用的文件是存在的。
使用方法: swupdate -c -i &lt;file&gt;</td>
</tr>
<tr class="row-even"><td>-p</td>
<td>string</td>
<td>执行安装后命令</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>-d &lt;parms&gt;</td>
<td>string</td>
<td>选中 CONFIG_DOWNLOAD 时可用
启动内部下载程序客户端，
并将命令行字符串传递给它。
请参阅下载程序的内部命令行参数</td>
</tr>
<tr class="row-odd"><td>-u &lt;url&gt;</td>
<td>string</td>
<td>这是提取新软件的URL。
URL是指向有效.swu镜像的链接</td>
</tr>
<tr class="row-even"><td>-r &lt;retries&gt;</td>
<td>integer</td>
<td>下载失败前重试的次数。使用“-r 0”，则
SWUpdate在加载到有效软件之前不会停止</td>
</tr>
<tr class="row-odd"><td>-t &lt;timeout&gt;</td>
<td>integer</td>
<td>判断下载连接丢失的超时时间</td>
</tr>
<tr class="row-even"><td>-a &lt;usr:pwd&gt;</td>
<td>string</td>
<td>发送用于基本身份验证的用户名和密码</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="systemd">
<h3>systemd集成<a class="headerlink" href="#systemd" title="永久链接至标题">¶</a></h3>
<p>SWUpdate 具有可选的 <a class="reference external" href="https://www.freedesktop.org/wiki/Software/systemd/">systemd</a> 支持，是由编译配置开关 <code class="docutils literal notranslate"><span class="pre">CONFIG_SYSTEMD</span></code>
控制的。如果启用，SWUpdate将向systemd发送关于启动完成的信号，
并可以可选地使用systemd的socket-based activation功能。</p>
<p>一个systemd服务单元文件的示例 <code class="docutils literal notranslate"><span class="pre">/etc/systemd/system/swupdate.service</span></code>
以suricatta守护进程模式启动SWUpdate，可能看起来像以下的样子：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">Unit</span><span class="p">]</span>
<span class="n">Description</span><span class="o">=</span><span class="n">SWUpdate</span> <span class="n">daemon</span>
<span class="n">Documentation</span><span class="o">=</span><span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">sbabic</span><span class="o">/</span><span class="n">swupdate</span>
<span class="n">Documentation</span><span class="o">=</span><span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">sbabic</span><span class="o">.</span><span class="n">github</span><span class="o">.</span><span class="n">io</span><span class="o">/</span><span class="n">swupdate</span>

<span class="p">[</span><span class="n">Service</span><span class="p">]</span>
<span class="n">Type</span><span class="o">=</span><span class="n">notify</span>
<span class="n">ExecStart</span><span class="o">=/</span><span class="n">usr</span><span class="o">/</span><span class="nb">bin</span><span class="o">/</span><span class="n">swupdate</span> <span class="o">-</span><span class="n">u</span> <span class="s1">&#39;-t default -u http://localhost -i 25&#39;</span>

<span class="p">[</span><span class="n">Install</span><span class="p">]</span>
<span class="n">WantedBy</span><span class="o">=</span><span class="n">multi</span><span class="o">-</span><span class="n">user</span><span class="o">.</span><span class="n">target</span>
</pre></div>
</div>
<p>通过 <code class="docutils literal notranslate"><span class="pre">systemctl</span> <span class="pre">start</span> <span class="pre">swupdate.service</span></code> 进行启动, SWUpdate在
启动时(重新)创建套接字。为了使用socket-based activation，还必须附带一个
systemd套接字单元文件 <code class="docutils literal notranslate"><span class="pre">/etc/systemd/system/swupdate.socket</span></code> ：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">Unit</span><span class="p">]</span>
<span class="n">Description</span><span class="o">=</span><span class="n">SWUpdate</span> <span class="n">socket</span> <span class="n">listener</span>
<span class="n">Documentation</span><span class="o">=</span><span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">sbabic</span><span class="o">/</span><span class="n">swupdate</span>
<span class="n">Documentation</span><span class="o">=</span><span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">sbabic</span><span class="o">.</span><span class="n">github</span><span class="o">.</span><span class="n">io</span><span class="o">/</span><span class="n">swupdate</span>

<span class="p">[</span><span class="n">Socket</span><span class="p">]</span>
<span class="n">ListenStream</span><span class="o">=/</span><span class="n">tmp</span><span class="o">/</span><span class="n">sockinstctrl</span>
<span class="n">ListenStream</span><span class="o">=/</span><span class="n">tmp</span><span class="o">/</span><span class="n">swupdateprog</span>

<span class="p">[</span><span class="n">Install</span><span class="p">]</span>
<span class="n">WantedBy</span><span class="o">=</span><span class="n">sockets</span><span class="o">.</span><span class="n">target</span>
</pre></div>
</div>
<p>在 <code class="docutils literal notranslate"><span class="pre">swupdate.socket</span></code> 被启动后, systemd创建套接字文件，
并在SWupdate启动时将它们交给SWUpdate.
例如，当与 <code class="docutils literal notranslate"><span class="pre">/tmp/swupdateprog</span></code> 对话时，systemd启动
<code class="docutils literal notranslate"><span class="pre">swupdate.service</span></code> 并移交套接字文件。
在以 <code class="docutils literal notranslate"><span class="pre">systemctl</span> <span class="pre">start</span> <span class="pre">swupdate.service</span></code> “常规”启动SWupdate时
也会传递Socket文件。</p>
<p>注意，两个 <code class="docutils literal notranslate"><span class="pre">ListenStream=</span></code> 指令中的套接字路径
必须与SWUpdate配置中的 <code class="docutils literal notranslate"><span class="pre">CONFIG_SOCKET_CTRL_PATH</span></code>
和 <code class="docutils literal notranslate"><span class="pre">CONFIG_SOCKET_PROGRESS_PATH</span></code> 中的套接字路径匹配。
这里描述了缺省套接字路径配置。</p>
</div>
</div>
<div class="section" id="id17">
<h2>引导启动程序的修改<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h2>
<p>SWUpdate 包含了内核和一个根文件系统(镜像),这必须由一个引导加载程序
来启动。如果使用U-Boot, 可以实现以下机制:</p>
<ul class="simple">
<li>U-Boot检查是否需要进行软件更新(检查gpio、串行控制台等)。</li>
<li>脚本“altbootcmd”设置启动SWUpdate的规则</li>
<li>当需要SWUpdate时, U-boot运行脚本”altbootcmd”</li>
</ul>
<p>更改U-Boot环境变量是安全的吗？是的，但是必须正确配置U-Boot。
Uboot支持双备份环境变量，这可以使得更新器件掉电是安全的。
板子的配置文件必须定义CONFIG_ENV_OFFSET_REDUND或CONFIG_ENV_ADDR_REDUND。
查阅U-Boot文档了解这些常量的作用以及如何使用它们。</p>
<p>还有一些可选的增强可以集成到U-boot中，以使系统更安全。
其中我会建议的最重要的一个，是添加启动技术支持到uboot中
(文档在uboot的docs路径下)。这讲允许U-Boot追踪对成功启动应用的尝试。
如果启动计数超过了限制，则可以自动启动SWupdate，以替代损坏了的软件。</p>
<p>GRUB默认情况下不像U-Boot那样支持环境变量的双副本。
这意味着，在环境块更新期间断电时，环境块有可能损坏。
为了最小化风险，我们没有直接修改原始环境块。
而是将变量写入临时文件，并在操作成功后调用rename指令。</p>
</div>
<div class="section" id="id18">
<h2>构建一个单个的镜像<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h2>
<p>cpio由于其简单性而被用作容器。由此可以很简单地生成镜像。
描述镜像的文件(默认是”sw-description”，但是名称是可以配置的)
必须是cpio归档中的第一个文件。
要生成镜像，可以使用以下脚本:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>CONTAINER_VER=&quot;1.0&quot;
PRODUCT_NAME=&quot;my-software&quot;
FILES=&quot;sw-description image1.ubifs  \
       image2.gz.u-boot uImage.bin myfile sdcard.img&quot;
for i in $FILES;do
        echo $i;done | cpio -ov -H crc &gt;  ${PRODUCT_NAME}_${CONTAINER_VER}.swu
</pre></div>
</div>
<p>单个的子图像可以在cpio容器中按任意顺序放置，除了sw-description，它必须是第一个子镜像。
要检查生成的镜像，可以运行以下命令:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">swupdate</span> <span class="o">-</span><span class="n">c</span> <span class="o">-</span><span class="n">i</span> <span class="n">my</span><span class="o">-</span><span class="n">software_1</span><span class="o">.</span><span class="mf">0.</span><span class="n">swu</span>
</pre></div>
</div>
<div class="section" id="id19">
<h3>对复合镜像的支持<a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h3>
<p>在Yocto中可以自动生成单个镜像。
meta-swupdate使用swupdate类扩展了类。
配方应该继承它，并添加自己的sw-description文件来生成镜像。</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="sw-description.html" class="btn btn-neutral float-right" title="SWUpdate:使用默认解析器的语法和标记" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="licensing.html" class="btn btn-neutral" title="许可证" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2013-2018, Stefano Babic

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/translations.js"></script>
    

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>