

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>SWUpdate: software update for embedded system &mdash; Embedded Software Update Documentation 2018.11 文档</title>
  

  
  
    <link rel="shortcut icon" href="_static/SWUpdate.ico"/>
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" />
    <link rel="next" title="SWUpdate: syntax and tags with the default parser" href="sw-description.html" />
    <link rel="prev" title="License" href="licensing.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Embedded Software Update Documentation
          

          
          </a>

          
            
            
              <div class="version">
                2018.11
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="overview.html">嵌入式系统的软件管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="licensing.html">License</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">SWUpdate: software update for embedded system</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#features">Features</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#general-overview">General Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#single-image-delivery">Single image delivery</a></li>
<li class="toctree-l3"><a class="reference internal" href="#streaming-feature">Streaming feature</a></li>
<li class="toctree-l3"><a class="reference internal" href="#images-fully-streamed">Images fully streamed</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#configuration-and-build">Configuration and build</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#requirements">Requirements</a></li>
<li class="toctree-l3"><a class="reference internal" href="#building-with-yocto">Building with Yocto</a></li>
<li class="toctree-l3"><a class="reference internal" href="#what-about-libubootenv">What about libubootenv ?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#configuring-swupdate">Configuring SWUpdate</a></li>
<li class="toctree-l3"><a class="reference internal" href="#building">Building</a></li>
<li class="toctree-l3"><a class="reference internal" href="#building-a-debian-package">Building a debian package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#steps-for-building-a-debian-package">Steps for building a debian package</a></li>
<li class="toctree-l4"><a class="reference internal" href="#alternative-way-signing-source-package">Alternative way signing source package</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#running-swupdate">Running SWUpdate</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#what-is-expected-from-a-swupdate-run">What is expected from a SWUpdate run</a></li>
<li class="toctree-l3"><a class="reference internal" href="#command-line-parameters">Command line parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="#systemd-integration">systemd Integration</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#changes-in-boot-loader-code">Changes in boot-loader code</a></li>
<li class="toctree-l2"><a class="reference internal" href="#building-a-single-image">Building a single image</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#support-of-compound-image">Support of compound image</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="sw-description.html">SWUpdate: syntax and tags with the default parser</a></li>
<li class="toctree-l1"><a class="reference internal" href="signed_images.html">Update images from verified source</a></li>
<li class="toctree-l1"><a class="reference internal" href="encrypted_images.html">Symmetrically Encrypted Update Images</a></li>
<li class="toctree-l1"><a class="reference internal" href="handlers.html">Handlers</a></li>
<li class="toctree-l1"><a class="reference internal" href="mongoose.html">Mongoose daemon mode</a></li>
<li class="toctree-l1"><a class="reference internal" href="suricatta.html">Suricatta daemon mode</a></li>
<li class="toctree-l1"><a class="reference internal" href="swupdate-ipc.html">SWUpdate: API for external programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="progress.html">Getting information on running update</a></li>
<li class="toctree-l1"><a class="reference internal" href="building-with-yocto.html">meta-swupdate: building with Yocto</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="help_and_support.html">Help and support</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing to SWUpdate</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="roadmap.html">Project’s road-map</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Embedded Software Update Documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>SWUpdate: software update for embedded system</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/swupdate.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="swupdate-software-update-for-embedded-system">
<h1>SWUpdate: software update for embedded system<a class="headerlink" href="#swupdate-software-update-for-embedded-system" title="永久链接至标题">¶</a></h1>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="永久链接至标题">¶</a></h2>
<p>This project is thought to help to update an embedded
system from a storage media or from network. However,
it should be mainly considered as a framework, where
further protocols or installers (in SWUpdate they are called handlers)
can be easily added to the application.</p>
<p>One use case is to update from an external local media, as
USB-Pen or SD-Card. In this case, the update is done
without any intervention by an operator: it is thought
as “one-key-update”, and the software is started at reset
simply pressing a key (or in any way that can be recognized
by the target), making all checks automatically. At the end,
the updating process reports only the status to the operator
(successful or failed).</p>
<p>The output can be displayed on a LCD using the frame-buffer
device or directed to a serial line (Linux console).</p>
<p>It is generally used in the single copy approach, running in an initrd
(recipes are provided to generate with Yocto).  However, it is
possible to use it in a double-copy approach by use of <a class="reference internal" href="sw-description.html#collections"><span class="std std-ref">Software collections</span></a>.</p>
<p>If started for a remote update, SWUpdate starts an embedded
Web-server and waits for requests. The operator must upload
a suitable image, that SWUpdate checks and then install.
All output is notified to the operator’s browser via AJAX
notifications.</p>
</div>
<div class="section" id="features">
<h2>Features<a class="headerlink" href="#features" title="永久链接至标题">¶</a></h2>
<div class="section" id="general-overview">
<h3>General Overview<a class="headerlink" href="#general-overview" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li>Install on embedded Media (eMMC, SD, Raw NAND,
NOR and SPI-NOR flashes)</li>
<li>check if an image is available. The image is built
in a specified format (cpio) and it must contain
a file describing the software that must be updated.</li>
<li>SWUpdate is thought to update UBI volumes (mainly for NAND, but not only)
and images on devices. Passing a whole image can still be updated
as a partition on the SD card, or a MTD partition.</li>
<li>new partition schema. This is bound with UBI volume.
SWUpdate can recreate UBI volumes, resizing them and
copying the new software. A special UBI volume with the name “data”
is saved and restored after repartitioning with all data
it contains,  to maintain user’s data.</li>
<li>support for compressed images, using the zlib library.
tarball (tgz file) are supported.</li>
<li>support for partitioned USB-pen or unpartitioned (mainly
used by Windows).</li>
<li>support for updating a single file inside a filesystem.
The filesystem where to put the file must be described.</li>
<li>checksum for the single components of an image</li>
<li>use a structured language to describe the image. This is done
using the <a class="reference external" href="http://www.hyperrealm.com/libconfig/">libconfig</a> library as default parser, that uses a
JSON-like description.</li>
<li>use custom’s choice for the description of the image. It is
possible to write an own parser using the Lua language.
An example using a XML description in Lua is provided
in the examples directory.</li>
<li>Support for setting / erasing U-Boot variables</li>
<li>Support for setting / erasing <a class="reference external" href="https://www.gnu.org/software/grub/manual/html_node/Environment-block.html">GRUB</a> environment block variables</li>
<li>Support for setting / erasing <a class="reference external" href="https://github.com/siemens/efibootguard">EFI Boot Guard</a> variables</li>
<li>Support for preinstall scripts. They run before updating the images</li>
<li>Support for postinstall scripts. They run after updating the images.</li>
<li>Network installer using an embedded Web-server (Mongoose Server
was chosen, in the version under Lua license). A different
Web-server can be used.</li>
<li><dl class="first docutils">
<dt>Multiple interfaces for getting software</dt>
<dd><ul class="first last">
<li>local Storage: USB, SD, UART,..</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>OTA / Remote</dt>
<dd><ul class="first last">
<li>integrated Web-Server</li>
<li>pulling from remote Server (HTTP, HTTPS, ..)</li>
<li>using a Backend. SWUpdate is open to talk with back end
servers for rolling out software updates.
Current version supports the Hawkbit server, but other
backend can be added.</li>
</ul>
</dd>
</dl>
</li>
<li>Can be configured to check for compatibility between software and hardware
revisions. The software image must contain an entry declaring on which
HW revision the software is allowed to run.
SWUpdate refuses to install if the compatibility is not verified.</li>
<li>support for image extraction. A manufacturer can require to have
a single image that contains the software for more as one device.
This simplifies the manufacturer’s management and reduces
their administrative costs having a single software product.
SWUpdate receives the software as stream without temporary storing,
and extracts only the required components for the device
to be installed.</li>
<li>allow custom handlers for installing FPGA firmware,
micro-controller firmware via custom protocols.</li>
<li>Features are enabled / disabled using “make menuconfig”.
(Kbuild is inherited from busybox project)</li>
<li>Images are authenticated and verified before installing</li>
<li>Power-Off safe</li>
</ul>
</div>
<div class="section" id="single-image-delivery">
<h3>Single image delivery<a class="headerlink" href="#single-image-delivery" title="永久链接至标题">¶</a></h3>
<p>The main concept is that the manufacturer delivers a single
big image. All single images are packed together (cpio was chosen
for its simplicity and because can be streamed) together with
an additional file (sw-description), that contains meta
information about each single image.</p>
<p>The format of sw-description can be customized: SWUpdate can be
configured to use its internal parser (based on libconfig), or calling
an external parser in Lua.</p>
<img alt="_images/image_format.png" src="_images/image_format.png" />
<p>Changing the rules to accept images with an external parser,
let to extend to new image types and how they are installed.
In fact, the scope of the parser is to retrieve which single
images must be installed and how.
SWUpdate implements “handlers” to install a single image:
there are handlers to install images into UBI volumes,
or to a SD card, a CFI Flash, and so on. It is then easy to
add an own handler if a very special installer is required.</p>
<p>For example we can think at a project with a main processor and
one or several micro-controllers. Let’s say for simplicity that
the main processor communicates with the micro-controllers via
UARTS using a proprietary protocol. The software on the micro-controllers
can be updated using the proprietary protocol.</p>
<p>It is possible to extend SWUpdate writing a handler, that implements
the part of the proprietary protocol to perform the upgrade
on the micro-controller. The parser must recognize which image must be
installed with the new handler, and SWUpdate will call the handler
during the installation process.</p>
</div>
<div class="section" id="streaming-feature">
<h3>Streaming feature<a class="headerlink" href="#streaming-feature" title="永久链接至标题">¶</a></h3>
<p>SWUpdate is thought to be able to stream the received image directly into
the target, without any temporary copy. In fact, the single installer
(handler) receive as input the file descriptor set at the beginning of
the image that must be installed.</p>
<p>The feature can be set on image basis, that means that a user can
decide which partial images should be streamed. If not streamed (see
installed-directly flag), files are temporary extracted into the directory
pointed to by the environment variable <code class="docutils literal notranslate"><span class="pre">TMPDIR</span></code> with <code class="docutils literal notranslate"><span class="pre">/tmp</span></code> as
fall-back if <code class="docutils literal notranslate"><span class="pre">TMPDIR</span></code> is not set.
Of course, by streaming it is not possible to make checks on the whole delivered
software before installing.
The temporary copy is done only when updated from network. When the image
is stored on an external storage, there is no need of that copy.</p>
</div>
<div class="section" id="images-fully-streamed">
<h3>Images fully streamed<a class="headerlink" href="#images-fully-streamed" title="永久链接至标题">¶</a></h3>
<p>In case of remote update, SWUpdate extracts relevant images from the stream
and copies them into the directory pointed to by the environment variable
<code class="docutils literal notranslate"><span class="pre">TMPDIR</span></code> (if unset, to <code class="docutils literal notranslate"><span class="pre">/tmp</span></code>) before calling the handlers.
This guarantee that an update is initiated only if all parts are present and
correct. However, on some systems with less resources, the amount of RAM
to copy the images could be not enough, for example if the filesystem on
an attached SD Card must be updated. In this case, it will help if the images
are installed directly as stream by the corresponding handler, without temporary
copies. Not all handlers support to stream directly into the target.
Streaming with zero-copy is enabled by setting the flag “installed-directly”
in the description of the single image.</p>
</div>
</div>
<div class="section" id="configuration-and-build">
<h2>Configuration and build<a class="headerlink" href="#configuration-and-build" title="永久链接至标题">¶</a></h2>
<div class="section" id="requirements">
<h3>Requirements<a class="headerlink" href="#requirements" title="永久链接至标题">¶</a></h3>
<p>There are only a few libraries that are required to compile SWUpdate.</p>
<ul class="simple">
<li>mtd-utils: internally, mtd-utils generates libmtd and libubi.
They are commonly not exported and not installed, but they are
linked by SWUpdate to reuse the same functions for upgrading
MTD and UBI volumes.</li>
<li>openssl: required with the Webserver</li>
<li>Lua: liblua and the development headers.</li>
<li>libz, libcrypto are always linked.</li>
<li>libconfig: it is used by the default parser.</li>
<li>libarchive (optional) for archive handler</li>
<li>libjson (optional) for JSON parser and Hawkbit</li>
<li>libubootenv (optional) if support for U-Boot is enabled</li>
<li>libebgenv (optional) if support for EFI Boot Guard is enabled</li>
<li>libcurl used to communicate with network</li>
</ul>
<p>New handlers can add some other libraries to the requirement list -
check if you need all handlers in case you get build errors,
and drop what you do not need.</p>
</div>
<div class="section" id="building-with-yocto">
<h3>Building with Yocto<a class="headerlink" href="#building-with-yocto" title="永久链接至标题">¶</a></h3>
<p>A <a class="reference external" href="https://github.com/sbabic/meta-swupdate.git">meta-swupdate</a> layer is provided. It contains the required changes
for mtd-utils and for generating Lua. Using meta-SWUpdate is a
straightforward process.</p>
<p>Firstly, clone meta-SWUpdate.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">clone</span> <span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">sbabic</span><span class="o">/</span><span class="n">meta</span><span class="o">-</span><span class="n">swupdate</span><span class="o">.</span><span class="n">git</span>
</pre></div>
</div>
<p>Add meta-SWUpdate as usual to your bblayers.conf. You have also
to add meta-oe to the list.</p>
<p>In meta-SWUpdate there is a recipe to generate an initrd with a
rescue system with SWUpdate. Use:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MACHINE</span><span class="o">=&lt;</span><span class="n">your</span> <span class="n">machine</span><span class="o">&gt;</span> <span class="n">bitbake</span> <span class="n">swupdate</span><span class="o">-</span><span class="n">image</span>
</pre></div>
</div>
<p>You will find the result in your tmp/deploy/&lt;your machine&gt; directory.
How to install and start an initrd is very target specific - please
check in the documentation of your bootloader.</p>
</div>
<div class="section" id="what-about-libubootenv">
<h3>What about libubootenv ?<a class="headerlink" href="#what-about-libubootenv" title="永久链接至标题">¶</a></h3>
<p>This is a common issue when SWUpdate is built. SWUpdate depends on this library,
that is generated from the U-Boot’s sources. This library allows to safe modify
the U-Boot environment. It is not required if U-Boot is not used as bootloader.
If SWUpdate cannot be linked, you are using an old version of U-Boot (you need
at least 2016.05). If this is the case, you can add your own recipe for
the package u-boot-fw-utils, adding the code for the library.</p>
<p>It is important that the package u-boot-fw-utils is built with the same
sources of the bootloader and for the same machine. In fact, the target
can have a default environment linked together with U-Boot’s code,
and it is not (yet) stored into a storage. SWUpdate should be aware of
it, because it cannot read it: the default environment must be linked
as well to SWUpdate’s code. This is done inside the libubootenv.</p>
<p>If you build for a different machine, SWUpdate will destroy the
environment when it tries to change it the first time. In fact,
a wrong default environment is taken, and your board won’t boot again.</p>
</div>
<div class="section" id="configuring-swupdate">
<h3>Configuring SWUpdate<a class="headerlink" href="#configuring-swupdate" title="永久链接至标题">¶</a></h3>
<p>SWUpdate is configurable via “make menuconfig”. The small footprint
is reached using the internal parser and disabling the web server.
Any option has a small help describing its usage. In the default
configuration, many options are already activated.</p>
<p>To configure the options:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">menuconfig</span>
</pre></div>
</div>
</div>
<div class="section" id="building">
<h3>Building<a class="headerlink" href="#building" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li>to cross-compile, set the CC and CXX variables before running make.
It is also possible to set the cross-compiler prefix as option with
make menuconfig.</li>
<li>generate the code</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span>
</pre></div>
</div>
<p>The result is the binary “swupdate”. A second binary “progress” is built,
but it is not strictly required. It is an example how to build your
own interface to SWUpdate to show a progress bar or whatever you want on your
HMI. The example simply prints on the console the current status of the update.</p>
<p>In the Yocto buildsystem,:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bitbake</span> <span class="n">swupdate</span>
</pre></div>
</div>
<p>This will build the package</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bitbake</span> <span class="n">swupdate</span><span class="o">-</span><span class="n">image</span>
</pre></div>
</div>
<p>This builds a rescue image. The result is a Ramdisk that
can be loaded directly by the bootloader.
To use SWUpdate in the double-copy mode, put the package
swupdate into your rootfs. Check your image recipe, and
simply add it to the list of the installed packages.</p>
<p>For example, if we want to add it to the standard “core-image-full-cmdline”
image, we can add a <em>recipes-extended/images/core-image-full-cmdline.bbappend</em></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">IMAGE_INSTALL</span> <span class="o">+=</span> <span class="s2">&quot; </span><span class="se">\</span>
<span class="s2">                        swupdate </span><span class="se">\</span>
<span class="s2">                        swupdate-www </span><span class="se">\</span>
<span class="s2">                 &quot;</span>
</pre></div>
</div>
<p>swupdate-www is the package with the website, that you can customize with
your own logo, template ans style.</p>
</div>
<div class="section" id="building-a-debian-package">
<h3>Building a debian package<a class="headerlink" href="#building-a-debian-package" title="永久链接至标题">¶</a></h3>
<p>SWUpdate is thought for Embedded Systems and building in an embedded
distribution is the first use case. But apart the most used buildsystems
for embedded as Yocto or Buildroot, in some cases a standard Linux distro
is used. Not only, a distro package allows to run SWUpdate on Linux PC
for test purposes without having to fight with dependencies. Using the
debhelper tools, it is possible to generate a debian package.</p>
<div class="section" id="steps-for-building-a-debian-package">
<h4>Steps for building a debian package<a class="headerlink" href="#steps-for-building-a-debian-package" title="永久链接至标题">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">./</span><span class="n">debian</span><span class="o">/</span><span class="n">rules</span> <span class="n">clean</span>
<span class="o">./</span><span class="n">debian</span><span class="o">/</span><span class="n">rules</span> <span class="n">build</span>
<span class="n">fakeroot</span> <span class="n">debian</span><span class="o">/</span><span class="n">rules</span> <span class="n">binary</span>
</pre></div>
</div>
<p>The result is a “deb” package stored in the parent directory.</p>
</div>
<div class="section" id="alternative-way-signing-source-package">
<h4>Alternative way signing source package<a class="headerlink" href="#alternative-way-signing-source-package" title="永久链接至标题">¶</a></h4>
<p>You can use dpkg-buildpackage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dpkg</span><span class="o">-</span><span class="n">buildpackage</span> <span class="o">-</span><span class="n">us</span> <span class="o">-</span><span class="n">uc</span>
<span class="n">debsign</span> <span class="o">-</span><span class="n">k</span> <span class="o">&lt;</span><span class="n">keyId</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="running-swupdate">
<h2>Running SWUpdate<a class="headerlink" href="#running-swupdate" title="永久链接至标题">¶</a></h2>
<div class="section" id="what-is-expected-from-a-swupdate-run">
<h3>What is expected from a SWUpdate run<a class="headerlink" href="#what-is-expected-from-a-swupdate-run" title="永久链接至标题">¶</a></h3>
<p>A run of SWUpdate consists mainly of the following steps:</p>
<ul class="simple">
<li>check for media (USB-pen)</li>
<li>check for an image file. The extension must be .swu</li>
<li>extracts sw-description from the image and verifies it
It parses sw-description creating a raw description in RAM
about the activities that must be performed.</li>
<li>Reads the cpio archive and proofs the checksum of each single file
SWUpdate stops if the archive is not complete verified</li>
<li>check for hardware-software compatibility, if any,
reading hardware revision from hardware and matching
with the table in sw-description.</li>
<li>check that all components described in sw-description are
really in the cpio archive.</li>
<li>modify partitions, if required. This consists in a resize
of UBI volumes, not a resize of MTD partition.
A volume with the name “data” is saved and restored after
resizing.</li>
<li>runs pre-install scripts</li>
<li>iterates through all images and call the corresponding
handler for installing on target.</li>
<li>runs post-install scripts</li>
<li>update bootloader environment, if changes are specified
in sw-description.</li>
<li>reports the status to the operator (stdout)</li>
</ul>
<p>The first step that fails, stops the entire procedure and
an error is reported.</p>
<p>To start SWUpdate expecting the image from a file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">swupdate</span> <span class="o">-</span><span class="n">i</span> <span class="o">&lt;</span><span class="n">filename</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>To start with the embedded web server:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">swupdate</span> <span class="o">-</span><span class="n">w</span> <span class="s2">&quot;&lt;web server options&gt;&quot;</span>
</pre></div>
</div>
<p>The main important parameters for the web server are “document-root” and “port”.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">swupdate</span> <span class="o">-</span><span class="n">w</span> <span class="s2">&quot;--document-root ./www --port 8080&quot;</span>
</pre></div>
</div>
<p>The embedded web server is taken from the Mongoose project.</p>
<p>The whole list of options will be retrieved with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">swupdate</span> <span class="o">-</span><span class="n">h</span>
</pre></div>
</div>
<p>This uses as website the pages delivered with the code. Of course,
they can be customized and replaced. The website uses AJAX to communicate
with SWUpdate, and to show the progress of the update to the operator.</p>
<p>The default port of the Web-server is 8080. You can then connect to the target
with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">http</span><span class="p">:</span><span class="o">//&lt;</span><span class="n">target_ip</span><span class="o">&gt;</span><span class="p">:</span><span class="mi">8080</span>
</pre></div>
</div>
<p>If it works, the start page should be displayed as in next figure.</p>
<img alt="_images/website.png" src="_images/website.png" />
<p>If a correct image is downloaded, SWUpdate starts to process the received image.
All notifications are sent back to the browser. SWUpdate provides a mechanism
to send to a receiver the progress of the installation. In fact, SWUpdate
takes a list of objects that registers itself with the application
and they will be informed any time the application calls the notify() function.
This allows also for self-written handlers to inform the upper layers about
error conditions or simply return the status. It is then simply to add
own receivers to implement customized way to display the results: displaying
on a LCD (if the target has one), or sending back to another device via
network.
An example of the notifications sent back to the browser is in the next figure:</p>
<img alt="_images/webprogress.png" src="_images/webprogress.png" />
<p>Software collections can be specified by passing <cite>–select</cite> command
line option. Assuming <cite>sw-description</cite> file contains a collection
named <cite>stable</cite>, with <cite>alt</cite> installation location, <cite>SWUpdate</cite> can be
called like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">swupdate</span> <span class="o">--</span><span class="n">select</span> <span class="n">stable</span><span class="p">,</span><span class="n">alt</span>
</pre></div>
</div>
</div>
<div class="section" id="command-line-parameters">
<h3>Command line parameters<a class="headerlink" href="#command-line-parameters" title="永久链接至标题">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="15%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>-f &lt;file&gt;</td>
<td>string</td>
<td>SWUpdate config file to use</td>
</tr>
<tr class="row-odd"><td>-b &lt;string&gt;</td>
<td>string</td>
<td>Active only if CONFIG_UBIATTACH is set
It allows to blacklist MTDs when SWUpdate
searches for UBI volumes.
Example: U-Boot and environment in MTD0-1:
<strong>swupdate -b “0 1”</strong></td>
</tr>
<tr class="row-even"><td>-e &lt;sel&gt;</td>
<td>string</td>
<td>sel is in the format &lt;software&gt;,&lt;mode&gt;
It allows to find a subset of rules in
the sw-description file. With it,
multiple rules are allowed.
One common usage is in case of the dual
copy approach. Example:
-e “stable, copy1”  ==&gt; install on copy1
-e “stable, copy2”  ==&gt; install on copy2</td>
</tr>
<tr class="row-odd"><td>-h</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>run usage with help</td>
</tr>
<tr class="row-even"><td>-k</td>
<td>string</td>
<td>Active if CONFIG_SIGNED is set
Filename with the public key</td>
</tr>
<tr class="row-odd"><td>-l &lt;level&gt;</td>
<td>int</td>
<td>Set loglevel</td>
</tr>
<tr class="row-even"><td>-L</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>Send LOG output to syslog(local)</td>
</tr>
<tr class="row-odd"><td>-i &lt;file&gt;</td>
<td>string</td>
<td>run SWUpdate with a local .swu file</td>
</tr>
<tr class="row-even"><td>-n</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>run SWUpdate in dry-run mode.</td>
</tr>
<tr class="row-odd"><td>-N</td>
<td>string</td>
<td>passed the current installed version of
software. This will be checked with the
version of new software and forbids
downgrading.
Version mconsists of 4 number:
major.minor.rev.build
each field is in the range 0..65535</td>
</tr>
<tr class="row-even"><td>-o &lt;file&gt;</td>
<td>string</td>
<td>saves the stream (SWU) on a file</td>
</tr>
<tr class="row-odd"><td>-v</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>activate verbose output</td>
</tr>
<tr class="row-even"><td>-w &lt;parms&gt;</td>
<td>string</td>
<td>start internal webserver and pass to it
a command line string.</td>
</tr>
<tr class="row-odd"><td>-u &lt;parms&gt;</td>
<td>string</td>
<td>start internal suricatta client daemon and
pass to it a command line string.
see suricatta’s documentation for details.</td>
</tr>
<tr class="row-even"><td>-H
&lt;board:rev&gt;</td>
<td>string</td>
<td>set board name and Hardware revision</td>
</tr>
<tr class="row-odd"><td>-c</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>This will check <code class="docutils literal notranslate"><span class="pre">*.swu</span></code> file against
internal tests. It ensures that files
referenced in sw-description are present.
Usage: swupdate -c -i &lt;file&gt;</td>
</tr>
<tr class="row-even"><td>-p</td>
<td>string</td>
<td>Execute post-update command.</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>-d &lt;parms&gt;</td>
<td>string</td>
<td>Active only if CONFIG_DOWNLOAD is set
start internal downloader client and pass
to it a command line string.
See below the internal command line
arguments for the downloader</td>
</tr>
<tr class="row-odd"><td>-u &lt;url&gt;</td>
<td>string</td>
<td>This is the URL where new software is
pulled. URL is a link to a valid .swu image</td>
</tr>
<tr class="row-even"><td>-r &lt;retries&gt;</td>
<td>integer</td>
<td>Number of retries before a download is
considered broken. With “-r 0”, SWUpdate
will not stop until a valid software is
loaded.</td>
</tr>
<tr class="row-odd"><td>-t &lt;timeout&gt;</td>
<td>integer</td>
<td>Timeout for connection lost when
downloading</td>
</tr>
<tr class="row-even"><td>-a &lt;usr:pwd&gt;</td>
<td>string</td>
<td>Send user and password for Basic Auth</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="systemd-integration">
<h3>systemd Integration<a class="headerlink" href="#systemd-integration" title="永久链接至标题">¶</a></h3>
<p>SWUpdate has optional <a class="reference external" href="https://www.freedesktop.org/wiki/Software/systemd/">systemd</a> support via the compile-time
configuration switch <code class="docutils literal notranslate"><span class="pre">CONFIG_SYSTEMD</span></code>. If enabled, SWUpdate
signals systemd about start-up completion and can make optional
use of systemd’s socket-based activation feature.</p>
<p>A sample systemd service unit file <code class="docutils literal notranslate"><span class="pre">/etc/systemd/system/swupdate.service</span></code>
may look like the following starting SWUpdate in suricatta daemon mode:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">Unit</span><span class="p">]</span>
<span class="n">Description</span><span class="o">=</span><span class="n">SWUpdate</span> <span class="n">daemon</span>
<span class="n">Documentation</span><span class="o">=</span><span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">sbabic</span><span class="o">/</span><span class="n">swupdate</span>
<span class="n">Documentation</span><span class="o">=</span><span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">sbabic</span><span class="o">.</span><span class="n">github</span><span class="o">.</span><span class="n">io</span><span class="o">/</span><span class="n">swupdate</span>

<span class="p">[</span><span class="n">Service</span><span class="p">]</span>
<span class="n">Type</span><span class="o">=</span><span class="n">notify</span>
<span class="n">ExecStart</span><span class="o">=/</span><span class="n">usr</span><span class="o">/</span><span class="nb">bin</span><span class="o">/</span><span class="n">swupdate</span> <span class="o">-</span><span class="n">u</span> <span class="s1">&#39;-t default -u http://localhost -i 25&#39;</span>

<span class="p">[</span><span class="n">Install</span><span class="p">]</span>
<span class="n">WantedBy</span><span class="o">=</span><span class="n">multi</span><span class="o">-</span><span class="n">user</span><span class="o">.</span><span class="n">target</span>
</pre></div>
</div>
<p>Started via <code class="docutils literal notranslate"><span class="pre">systemctl</span> <span class="pre">start</span> <span class="pre">swupdate.service</span></code>, SWUpdate
(re)creates its sockets on startup. For using socket-based
activation, an accompanying systemd socket unit file
<code class="docutils literal notranslate"><span class="pre">/etc/systemd/system/swupdate.socket</span></code> is required:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">Unit</span><span class="p">]</span>
<span class="n">Description</span><span class="o">=</span><span class="n">SWUpdate</span> <span class="n">socket</span> <span class="n">listener</span>
<span class="n">Documentation</span><span class="o">=</span><span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">sbabic</span><span class="o">/</span><span class="n">swupdate</span>
<span class="n">Documentation</span><span class="o">=</span><span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">sbabic</span><span class="o">.</span><span class="n">github</span><span class="o">.</span><span class="n">io</span><span class="o">/</span><span class="n">swupdate</span>

<span class="p">[</span><span class="n">Socket</span><span class="p">]</span>
<span class="n">ListenStream</span><span class="o">=/</span><span class="n">tmp</span><span class="o">/</span><span class="n">sockinstctrl</span>
<span class="n">ListenStream</span><span class="o">=/</span><span class="n">tmp</span><span class="o">/</span><span class="n">swupdateprog</span>

<span class="p">[</span><span class="n">Install</span><span class="p">]</span>
<span class="n">WantedBy</span><span class="o">=</span><span class="n">sockets</span><span class="o">.</span><span class="n">target</span>
</pre></div>
</div>
<p>On <code class="docutils literal notranslate"><span class="pre">swupdate.socket</span></code> being started, systemd creates the socket
files and hands them over to SWUpdate when it starts. So, for
example, when talking to <code class="docutils literal notranslate"><span class="pre">/tmp/swupdateprog</span></code>, systemd starts
<code class="docutils literal notranslate"><span class="pre">swupdate.service</span></code> and hands-over the socket files. The socket
files are also handed over on a “regular” start of SWUpdate via
<code class="docutils literal notranslate"><span class="pre">systemctl</span> <span class="pre">start</span> <span class="pre">swupdate.service</span></code>.</p>
<p>Note that the socket paths in the two <code class="docutils literal notranslate"><span class="pre">ListenStream=</span></code> directives
have to match the socket paths <code class="docutils literal notranslate"><span class="pre">CONFIG_SOCKET_CTRL_PATH</span></code> and
<code class="docutils literal notranslate"><span class="pre">CONFIG_SOCKET_PROGRESS_PATH</span></code> in SWUpdate’s configuration.
Here, the default socket path configuration is depicted.</p>
</div>
</div>
<div class="section" id="changes-in-boot-loader-code">
<h2>Changes in boot-loader code<a class="headerlink" href="#changes-in-boot-loader-code" title="永久链接至标题">¶</a></h2>
<p>The SWUpdate consists of kernel and a root filesystem
(image) that must be started by the boot-loader.
In case using U-Boot, the following mechanism can be implemented:</p>
<ul class="simple">
<li>U-Boot checks if a sw update is required (check gpio, serial console, etc.).</li>
<li>the script “altbootcmd” sets the rules to start SWUpdate</li>
<li>in case SWUpdate is required, U-boot run the script “altbootcmd”</li>
</ul>
<p>Is it safe to change U-Boot environment ? Well, it is, but U-Boot must
be configured correctly. U-Boot supports two copies of the environment
to be power-off safe during an environment update. The board’s
configuration file must have defined CONFIG_ENV_OFFSET_REDUND or
CONFIG_ENV_ADDR_REDUND. Check in U-Boot documentation for these
constants and how to use them.</p>
<p>There are a further enhancement that can be optionally integrated
into U-boot to make the system safer. The most important I will
suggest is to add support for boot counter in U-boot (documentation
is in U-Boot docs). This allows U-Boot to track for attempts to
successfully run the application, and if the boot counter is
greater as a limit, can start automatically SWUpdate to replace
a corrupt software.</p>
<p>GRUB by default does not support double copies of environment as in case of
U-Boot. This means that there is possibility that environment block get’s
corrupted when power-off occurs during environment update. To minimize the
risk, we are not modifying original environment block. Variables are written
into temporary file and after successful operation rename instruction is
called.</p>
</div>
<div class="section" id="building-a-single-image">
<h2>Building a single image<a class="headerlink" href="#building-a-single-image" title="永久链接至标题">¶</a></h2>
<p>cpio is used as container for its simplicity. The resulting image is very
simple to be built.
The file describing the images (“sw-description”, but the name can be
configured) must be the first file in the cpio archive.</p>
<p>To produce an image, a script like this can be used:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>CONTAINER_VER=&quot;1.0&quot;
PRODUCT_NAME=&quot;my-software&quot;
FILES=&quot;sw-description image1.ubifs  \
       image2.gz.u-boot uImage.bin myfile sdcard.img&quot;
for i in $FILES;do
        echo $i;done | cpio -ov -H crc &gt;  ${PRODUCT_NAME}_${CONTAINER_VER}.swu
</pre></div>
</div>
<p>The single images can be put in any order inside the cpio container, with the
exception of sw-description, that must be the first one.
To check your generated image you can run the following command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">swupdate</span> <span class="o">-</span><span class="n">c</span> <span class="o">-</span><span class="n">i</span> <span class="n">my</span><span class="o">-</span><span class="n">software_1</span><span class="o">.</span><span class="mf">0.</span><span class="n">swu</span>
</pre></div>
</div>
<div class="section" id="support-of-compound-image">
<h3>Support of compound image<a class="headerlink" href="#support-of-compound-image" title="永久链接至标题">¶</a></h3>
<p>The single image can be built automatically inside Yocto.
meta-swupdate extends the classes with the swupdate class. A recipe
should inherit it, and add your own sw-description file to generate the image.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="sw-description.html" class="btn btn-neutral float-right" title="SWUpdate: syntax and tags with the default parser" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="licensing.html" class="btn btn-neutral" title="License" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2013-2018, Stefano Babic

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/translations.js"></script>
    

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>